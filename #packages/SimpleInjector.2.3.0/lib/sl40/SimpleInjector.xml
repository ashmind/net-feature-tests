<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleInjector</name>
    </assembly>
    <members>
        <member name="T:SimpleInjector.ActivationException">
            <summary>
            The standard exception thrown when a container has an error in resolving an object.
            </summary>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class.
            </summary>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class with a specified error 
            message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:SimpleInjector.ActivationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.ActivationException"/> class with a specified error 
            message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception. 
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception, or a null reference (Nothing in Visual 
            Basic) if no inner exception is specified. 
            </param>
        </member>
        <member name="T:SimpleInjector.Advanced.AdvancedExtensions">
            <summary>
            Extension methods for enable advanced scenarios.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.IsLocked(SimpleInjector.Container)">
            <summary>
            Determines whether the specified container is locked making any new registrations. The container
            is automatically locked when <see cref="M:SimpleInjector.Container.GetInstance(System.Type)">GetInstance</see> is called for the
            first time.
            </summary>
            <param name="container">The container.</param>
            <returns>
              <c>true</c> if the specified container is locked; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/> is null.</exception>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.IsVerifying(SimpleInjector.Container)">
            <summary>Determines whether the specified container is currently verifying its configuration.</summary>
            <param name="container">The container.</param>
            <returns><c>true</c> if the specified container is verifying; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/> is null.</exception>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.GetInitializer``1(SimpleInjector.Container)">
            <summary>
            Builds up an <see cref="T:System.Action`1"/> delegate wrapping all <see cref="T:System.Action`1"/> delegates that
            are registered using <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">RegisterInitializer</see> and
            that apply to the given <typeparamref name="TService"/> (including delegates that are registered
            for interfaces <typeparamref name="TService"/> implements and base types that 
            <typeparamref name="TService"/> inherits from). <b>Null</b> will be returned when no delegates are
            registered that apply to this type.
            </summary>
            <param name="container">The container.</param>
            <remarks>
            This method has a performance caracteristic of O(n). Prevent from calling this in a performance
            critical path of the application.
            </remarks>
            <typeparam name="TService">The type for with an initializer must be built.</typeparam>
            <returns>An <see cref="T:System.Action`1"/> delegate or <b>null</b>.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.GetItem(SimpleInjector.Container,System.Object)">
            <summary>
            Retrieves an item from the container stored by the given <paramref name="key"/> or null when no
            item is stored by that key.
            </summary>
            <remarks>
            <b>Thread-safety:</b> Calls to this method are thread-safe, but users should take proper
            percausions when they call both <b>GetItem</b> and <see cref="M:SimpleInjector.Advanced.AdvancedExtensions.SetItem(SimpleInjector.Container,System.Object,System.Object)"/>.
            </remarks>
            <param name="container">The container.</param>
            <param name="key">The key of the item to retrieve.</param>
            <returns>The stored item or null (Nothing in VB).</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.SetItem(SimpleInjector.Container,System.Object,System.Object)">
            <summary>
            Stores an item by the given <paramref name="key"/> in the container. 
            </summary>
            <remarks>
            <b>Thread-safety:</b> Calls to this method are thread-safe, but users should take proper
            percausions when they call both <see cref="M:SimpleInjector.Advanced.AdvancedExtensions.GetItem(SimpleInjector.Container,System.Object)"/> and <b>SetItem</b>.
            </remarks>
            <param name="container">The container.</param>
            <param name="key">The key of the item to insert or override.</param>
            <param name="item">The actual item. May be null.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="container"/> or
            <paramref name="key"/> is a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Advanced.AdvancedExtensions.AppendToCollection(SimpleInjector.Container,System.Type,SimpleInjector.Registration)">
            <summary>
            Allows appending new registrations to existing registrations made using one of the
            <b>RegisterAll</b> overloads.
            </summary>
            <param name="container">The container.</param>
            <param name="serviceType">The service type of the collection.</param>
            <param name="registration">The registration to append.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when the <paramref name="serviceType"/> is not a
            reference type, is open generic, or ambiguous.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the container is locked.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when the method is called for a registration
            that is made with one of the <b>RegisterAll</b> overloads that accepts a dynamic collection
            (an <b>IEnumerable</b> or <b>IEnumerable&lt;TService&gt;</b>).</exception>
        </member>
        <member name="T:SimpleInjector.Advanced.IContainerControlledCollection">
            <summary>
            An IDecoratableEnumerable is a special enumerable that can be used more efficiently by the container
            to apply decorators to, with the biggest noticable difference that the registered predicate, will be
            checked for each service in the collection.
            </summary>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorInjectionBehavior">
            <summary>
            Defines the container's behavior for building an expression tree based on the supplied constructor of
            a given type.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorInjectionBehavior">ConstructorInjectionBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorInjectionBehavior.BuildParameterExpression(System.Reflection.ParameterInfo)">
            <summary>
            Builds an <see cref="T:System.Linq.Expressions.Expression"/> for the supplied <paramref name="parameter"/>, based on the
            container's configuration.
            </summary>
            <param name="parameter">The parameter.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/> that describes the intend of creating that 
            <paramref name="parameter"/>.</returns>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorResolutionBehavior">
            <summary>
            Defines the container's behavior for finding a suitable constructor for the creation of a type.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorResolutionBehavior">ConstructorResolutionBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorResolutionBehavior.GetConstructor(System.Type,System.Type)">
            <summary>
            Gets the given <paramref name="implementationType"/>'s constructor that can be used by the 
            container to create that instance.
            </summary>
            <param name="serviceType">Type of the abstraction that is requested.</param>
            <param name="implementationType">Type of the implementation to find a suitable constructor for.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/>.
            </returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when no suitable constructor could be found.</exception>
        </member>
        <member name="T:SimpleInjector.Advanced.IConstructorVerificationBehavior">
            <summary>
            Defines the container's behavior for verifying the constructor that will be picked by the
            <see cref="T:SimpleInjector.Advanced.IConstructorResolutionBehavior"/>.
            Set the <see cref="P:SimpleInjector.ContainerOptions.ConstructorVerificationBehavior">ConstructorVerificationBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IConstructorVerificationBehavior.Verify(System.Reflection.ParameterInfo)">
            <summary>Verifies the specified <paramref name="parameter"/>.</summary>
            <param name="parameter">The parameter.</param>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when the <paramref name="parameter"/> cannot be 
            used for auto wiring.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="parameter"/> is a
            null reference.</exception>
        </member>
        <member name="T:SimpleInjector.Advanced.IPropertySelectionBehavior">
            <summary>
            Defines the container's behavior for selecting properties to inject during the creation of a type.
            Set the <see cref="P:SimpleInjector.ContainerOptions.PropertySelectionBehavior">PropertySelectionBehavior</see> 
            property of the container's <see cref="P:SimpleInjector.Container.Options"/> property to change the default behavior 
            of the container. By default, no properties will be injected by the container.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.IPropertySelectionBehavior.SelectProperty(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            Determines whether a property should be injected by the container upon creation of its type.
            </summary>
            <param name="serviceType">Type of the abstraction that is requested.</param>
            <param name="propertyInfo">The property to check.</param>
            <returns>True when the property should be injected.</returns>
        </member>
        <member name="T:SimpleInjector.Advanced.KnownRelationship">
            <summary>
            A known relationship defines a relationship between two types. The Diagnostics Debug View uses this
            information to spot possible misconfigurations. 
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.KnownRelationship.#ctor(System.Type,SimpleInjector.Lifestyle,SimpleInjector.InstanceProducer)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> class.</summary>
            <param name="implementationType">The implementation type of the parent type.</param>
            <param name="lifestyle">The lifestyle of the parent type.</param>
            <param name="dependency">The type that the parent depends on (it is injected into the parent).</param>
        </member>
        <member name="M:SimpleInjector.Advanced.KnownRelationship.GetHashCode">
            <summary>Serves as a hash function for a particular type.</summary>
            <returns>A hash code for the current <see cref="T:SimpleInjector.Advanced.KnownRelationship"/>.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.KnownRelationship.Equals(SimpleInjector.Advanced.KnownRelationship)">
            <summary>
            Determines whether the specified <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> is equal to the current 
            <see cref="T:SimpleInjector.Advanced.KnownRelationship"/>.
            </summary>
            <param name="other">The object to compare with the current object.</param>
            <returns>True if the specified <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> is equal to the current 
            <see cref="T:SimpleInjector.Advanced.KnownRelationship"/>; otherwise, false.</returns>
        </member>
        <member name="P:SimpleInjector.Advanced.KnownRelationship.ImplementationType">
            <summary>Gets the implementation type of the parent type of the relationship.</summary>
            <value>The implementation type of the parent type of the relationship.</value>
        </member>
        <member name="P:SimpleInjector.Advanced.KnownRelationship.Lifestyle">
            <summary>Gets the lifestyle of the parent type of the relationship.</summary>
            <value>The lifestyle of the parent type of the relationship.</value>
        </member>
        <member name="P:SimpleInjector.Advanced.KnownRelationship.Dependency">
            <summary>Gets the type that the parent depends on (it is injected into the parent).</summary>
            <value>The type that the parent depends on.</value>
        </member>
        <member name="T:SimpleInjector.Container">
            <summary>
            The container. Create an instance of this type for registration of dependencies.
            </summary>
            <remarks>
            <para>
            <b>Thread-safety:</b>
            Resolving instances can be done safely from multiple threads concurrently, but registration needs to
            be done from one single thread.
            </para>
            <para> 
            It is therefore safe to call <see cref="M:SimpleInjector.Container.GetInstance(System.Type)"/>, <see cref="M:SimpleInjector.Container.GetAllInstances(System.Type)"/>, 
            <see cref="M:System.IServiceProvider.GetService(System.Type)">GetService</see>, <see cref="M:SimpleInjector.Container.GetRegistration(System.Type)"/> and
            <see cref="M:SimpleInjector.Container.GetCurrentRegistrations"/> and anything related to resolving instances from multiple thread 
            concurrently. It is however <b>unsafe</b> to call
            <see cref="M:SimpleInjector.Container.Register``2(SimpleInjector.Lifestyle)">RegisterXXX</see>,
            <see cref="E:SimpleInjector.Container.ExpressionBuilding"/>, <see cref="E:SimpleInjector.Container.ExpressionBuilt"/>, <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/>,
            <see cref="M:SimpleInjector.Container.AddRegistration(System.Type,SimpleInjector.Registration)"/> or anything related to registering from multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Container.#ctor">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Container"/> class.</summary>
        </member>
        <member name="M:SimpleInjector.Container.#ctor(SimpleInjector.ContainerOptions)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Container"/> class.</summary>
            <param name="options">The container options.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="options"/> is a null
            reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when supplied <paramref name="options"/> is an instance
            that already is supplied to another <see cref="T:SimpleInjector.Container"/> instance. Every container must get
            its own <see cref="T:SimpleInjector.ContainerOptions"/> instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetCurrentRegistrations">
            <summary>
            Returns an array with the current registrations. This list contains all explicitly registered
            types, and all implictly registered instances. Implicit registrations are  all concrete 
            unregistered types that have been requested, all types that have been resolved using
            unregistered type resolution (using the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event), and
            requested unregistered collections. Note that the result of this method may change over time, 
            because of these implicit registrations.
            </summary>
            <remarks>
            <para>
            This method has a performance caracteristic of O(n). Prevent from calling this in a performance
            critical path of the application.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same 
            <see cref="T:SimpleInjector.InstanceProducer"/> instance for a given <see cref="T:System.Type"/>. It will however either 
            always return <b>null</b> or always return a producer that is able to return the expected instance.
            Because of this, do not compare sets of instances returned by different calls to 
            <see cref="M:SimpleInjector.Container.GetCurrentRegistrations"/> by reference. The way of comparing lists is by the actual 
            type. The type of each instance is guaranteed to be unique in the returned list.
            </para>
            </remarks>
            <returns>An array of <see cref="T:SimpleInjector.InstanceProducer"/> instances.</returns>
        </member>
        <member name="M:SimpleInjector.Container.Equals(System.Object)">
            <summary>Determines whether the specified System.Object is equal to the current System.Object.
            </summary>
            <param name="obj">The System.Object to compare with the current System.Object.</param>
            <returns>
            True if the specified System.Object is equal to the current System.Object; otherwise, false.
            </returns>
        </member>
        <member name="M:SimpleInjector.Container.GetHashCode">
            <summary>Returns the hash code of the current instance.</summary>
            <returns>The hash code of the current instance.</returns>
        </member>
        <member name="M:SimpleInjector.Container.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the <see cref="T:SimpleInjector.Container"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the <see cref="T:SimpleInjector.Container"/>.
            </returns>
        </member>
        <member name="M:SimpleInjector.Container.GetType">
            <summary>Gets the <see cref="T:System.Type"/> of the current instance.</summary>
            <returns>The <see cref="T:System.Type"/> instance that represents the exact runtime 
            type of the current instance.</returns>
        </member>
        <member name="M:SimpleInjector.Container.LockContainer">
            <summary>Prevents any new registrations to be made to the container.</summary>
        </member>
        <member name="M:SimpleInjector.Container.Register``1">
            <summary>
            Registers that a new instance of <typeparamref name="TConcrete"/> will be returned every time it 
            is requested (transient). Note that calling this method is redundant in most scenarios, because
            the container will return a new instance for unregistered concrete types. Registration is needed
            when the security restrictions of the application's sandbox don't allow the container to create
            such type.
            </summary>
            <typeparam name="TConcrete">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <typeparamref name="TConcrete"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when the <typeparamref name="TConcrete"/> is a type
            that can not be created by the container.</exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``2">
            <summary>
            Registers that a new instance of <typeparamref name="TImplementation"/> will be returned every time a
            <typeparamref name="TService"/> is requested.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <typeparamref name="TImplementation"/> 
            type is not a type that can be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``1(System.Func{``0})">
            <summary>
            Registers the specified delegate that allows returning transient instances of 
            <typeparamref name="TService"/>. The delegate is expected to always return a new instance on
            each call.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">The delegate that allows building or creating new instances.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="instanceCreator"/> is a null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.Register(System.Type)">
            <summary>
            Registers that a new instance of <paramref name="concreteType"/> will be returned every time it 
            is requested (transient).
            </summary>
            <param name="concreteType">The concrete type that will be registered.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="concreteType"/> is a null 
            references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="concreteType"/> represents an 
            open generic type or is a type that can not be created by the container.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="concreteType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register(System.Type,System.Type)">
            <summary>
            Registers that a new instance of <paramref name="implementation"/> will be returned every time a
            <paramref name="serviceType"/> is requested. If <paramref name="serviceType"/> and 
            <paramref name="implementation"/> represent the same type, the type is registered by itself.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="implementation">The actual type that will be returned when requested.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="serviceType"/> or 
            <paramref name="implementation"/> are null references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="implementation"/> is
            no sub type from <paramref name="serviceType"/> (or the same type), or one of them represents an 
            open generic type.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register(System.Type,System.Func{System.Object})">
            <summary>
            Registers the specified delegate that allows returning instances of <paramref name="serviceType"/>.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instanceCreator">The delegate that will be used for creating new instances.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="serviceType"/> or 
            <paramref name="instanceCreator"/> are null references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an
            open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1">
            <summary>
            Registers a single concrete instance that will be constructed using constructor injection and will
            be returned when this instance is requested by type <typeparamref name="TConcrete"/>. 
            This <typeparamref name="TConcrete"/> must be thread-safe when working in a multi-threaded 
            environment.
            </summary>
            <typeparam name="TConcrete">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when 
            <typeparamref name="TConcrete"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when the <typeparamref name="TConcrete"/> is a type
            that can not be created by the container.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``2">
            <summary>
            Registers that the same a single instance of type <typeparamref name="TImplementation"/> will be 
            returned every time an <typeparamref name="TService"/> type is requested. If 
            <typeparamref name="TService"/> and <typeparamref name="TImplementation"/>  represent the same 
            type, the type is registered by itself. <typeparamref name="TImplementation"/> must be thread-safe 
            when working in a multi-threaded environment.
            </summary>
            <typeparam name="TService">
            The interface or base type that can be used to retrieve the instances.
            </typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <typeparamref name="TImplementation"/> 
            type is not a type that can be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1(``0)">
            <summary>
            Registers a single instance that will be returned when an instance of type 
            <typeparamref name="TService"/> is requested. This <paramref name="instance"/> must be thread-safe
            when working in a multi-threaded environment.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instance.</typeparam>
            <param name="instance">The instance to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when <paramref name="instance"/> is a null reference.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle``1(System.Func{``0})">
            <summary>
            Registers the specified delegate that allows constructing a single instance of 
            <typeparamref name="TService"/>. This delegate will be called at most once during the lifetime of 
            the application. The returned instance must be thread-safe when working in a multi-threaded 
            environment.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">The delegate that allows building or creating this single
            instance.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a 
            <paramref name="instanceCreator"/> for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="instanceCreator"/> is a 
            null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle(System.Type,System.Type)">
            <summary>
            Registers that the same instance of type <paramref name="implementation"/> will be returned every 
            time an instance of type <paramref name="serviceType"/> type is requested. If 
            <paramref name="serviceType"/> and <paramref name="implementation"/> represent the same type, the 
            type is registered by itself. <paramref name="implementation"/> must be thread-safe when working 
            in a multi-threaded environment.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="implementation">The actual type that will be returned when requested.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="serviceType"/> or 
            <paramref name="implementation"/> are null references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="implementation"/> is
            no sub type from <paramref name="serviceType"/>, or when one of them represents an open generic
            type.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle(System.Type,System.Func{System.Object})">
            <summary>
            Registers the specified delegate that allows constructing a single <paramref name="serviceType"/> 
            instance. The container will call this delegate at most once during the lifetime of the application.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instanceCreator">The delegate that will be used for creating that single instance.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an open
            generic type.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="serviceType"/> or 
            <paramref name="instanceCreator"/> are null references (Nothing in
            VB).</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterSingle(System.Type,System.Object)">
            <summary>
            Registers a single instance that will be returned when an instance of type 
            <paramref name="serviceType"/> is requested. This <paramref name="instance"/> must be thread-safe
            when working in a multi-threaded environment.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="instance">The instance to register.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="serviceType"/> or 
            <paramref name="instance"/> are null references (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="instance"/> is
            no sub type from <paramref name="serviceType"/>.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``2(SimpleInjector.Lifestyle)">
            <summary>
            Registers that an instance of <typeparamref name="TImplementation"/> will be returned when an
            instance of type <typeparamref name="TService"/> is requested. The instance is cached according to 
            the supplied <paramref name="lifestyle"/>.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <param name="lifestyle">The lifestyle that specifies how the returned instance will be cached.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <typeparamref name="TImplementation"/> 
            type is not a type that can be created by the container.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.Register``1(System.Func{``0},SimpleInjector.Lifestyle)">
            <summary>
            Registers the specified delegate <paramref name="instanceCreator"/> that will produce instances of
            type <typeparamref name="TService"/> and will be returned when an instance of type 
            <typeparamref name="TService"/> is requested. The delegate is expected to produce new instances on
            each call. The instances are cached according to the supplied <paramref name="lifestyle"/>.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">The delegate that allows building or creating new instances.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned instance will be cached.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <typeparamref name="TService"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when one of the supplied arguments is a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Container.Register(System.Type,System.Type,SimpleInjector.Lifestyle)">
            <summary>
            Registers that an instance of type <paramref name="implementationType"/> will be returned when an
            instance of type <paramref name="serviceType"/> is requested. The instance is cached according to 
            the supplied <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The interface or base type that can be used to retrieve the instances.</param>
            <param name="implementationType">The concrete type that will be registered.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned instance will be cached.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <paramref name="serviceType"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the given <paramref name="implementationType"/>
            type is not a type that can be created by the container, when either <paramref name="serviceType"/>
            or <paramref name="implementationType"/> are open generic types, or when 
            <paramref name="serviceType"/> is not assignable from the <paramref name="implementationType"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Container.Register(System.Type,System.Func{System.Object},SimpleInjector.Lifestyle)">
            <summary>
            Registers the specified delegate <paramref name="instanceCreator"/> that will produce instances of
            type <paramref name="serviceType"/> and will be returned when an instance of type 
            <paramref name="serviceType"/> is requested. The delegate is expected to produce new instances on 
            each call. The instances are cached according to the supplied <paramref name="lifestyle"/>.
            </summary>
            <param name="serviceType">The interface or base type that can be used to retrieve instances.</param>
            <param name="instanceCreator">The delegate that allows building or creating new instances.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned instance will be cached.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when the 
            <paramref name="serviceType"/> has already been registered.</exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when one of the supplied arguments is a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">
            <summary>
            Registers an <see cref="T:System.Action`1"/> delegate that runs after the creation of instances that
            implement or derive from the given <typeparamref name="TService"/>. Please note that only instances
            that are created by the container (using constructor injection) can be initialized this way.
            </summary>
            <typeparam name="TService">The type for which the initializer will be registered.</typeparam>
            <param name="instanceInitializer">The delegate that will be called after the instance has been
            constructed and before it is returned.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <paramref name="instanceInitializer"/> is a null reference.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered.</exception>
            <remarks>
            <para>
            Multiple <paramref name="instanceInitializer"/> delegates can be registered per 
            <typeparamref name="TService"/> and multiple initializers can be applied on a created instance,
            before it is returned. For instance, when registering a <paramref name="instanceInitializer"/>
            for type <see cref="T:System.Object"/>, the delegate will be called for every instance created by
            the container, which can be nice for debugging purposes.
            </para>
            <para>
            Note: Initializers are guaranteed to be executed in the order they are registered.
            </para>
            <para>
            The following example shows the usage of the 
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">RegisterInitializer</see> method:
            </para>
            <code lang="cs"><![CDATA[
            public interface ITimeProvider { DateTime Now { get; } }
            public interface ICommand { bool SendAsync { get; set; } }
            
            public abstract class CommandBase : ICommand
            {
                ITimeProvider Clock { get; set; }
                
                public bool SendAsync { get; set; }
            }
            
            public class ConcreteCommand : CommandBase { }
            
            [TestMethod]
            public static void TestRegisterInitializer()
            {
                // Arrange
                var container = new Container();
            
                container.Register<ICommand, ConcreteCommand>();
            
                // Configuring property injection for types that implement ICommand:
                container.RegisterInitializer<ICommand>(command =>
                {
                    command.SendAsync = true;
                });
            
                // Configuring property injection for types that implement CommandBase:
                container.RegisterInitializer<CommandBase>(command =>
                {
                    command.Clock = container.GetInstance<ITimeProvider>();
                });
                
                // Act
                var command = (ConcreteCommand)container.GetInstance<ICommand>();
            
                // Assert
                // Because ConcreteCommand implements both ICommand and CommandBase, 
                // both the initializers will have been executed.
                Assert.IsTrue(command.SendAsync);
                Assert.IsNotNull(command.Clock);
            }
            ]]></code>
            <para>
            The container does not use the type information of the requested service type, but it uses the 
            type information of the actual implementation to find all initialized that apply for that 
            type. This makes it possible to have multiple initializers to be applied on a single returned
            instance while keeping performance high.
            </para>
            <para>
            Registered initializers will only be applied to instances that are created by the container self
            (using constructor injection). Types that are newed up manually by supplying a 
            <see cref="T:System.Func`1"/> delegate to the container (using the 
            <see cref="M:SimpleInjector.Container.Register``1(System.Func{``0})"/> and 
            <see cref="M:SimpleInjector.Container.RegisterSingle``1(System.Func{``0})"/> methods) or registered as single instance
            (using <see cref="M:SimpleInjector.Container.RegisterSingle``1(``0)"/>) will not trigger initialization.
            When initialization of these instances is needed, this must be done manually, as can be seen in 
            the following example:
            <code lang="cs"><![CDATA[
            [TestMethod]
            public static void TestRegisterInitializer()
            {
                // Arrange
                int initializerCallCount = 0;
                
                var container = new Container();
                
                // Define a initializer for ICommand
                Action<ICommand> commandInitializer = command =>
                {
                    initializerCallCount++;
                });
                
                // Configuring that initializer.
                container.RegisterInitializer<ICommand>(commandInitializer);
                
                container.Register<ICommand>(() =>
                {
                    // Create a ConcreteCommand manually: will not be initialized.
                    var command = new ConcreteCommand("Data Source=.;Initial Catalog=db;");
                
                    // Run the initializer manually.
                    commandInitializer(command);
                
                    return command;
                });
                
                // Act
                var command = container.GetInstance<ICommand>();
            
                // Assert
                // The initializer will only be called once.
                Assert.AreEqual(1, initializerCallCount);
            }
            ]]></code>
            The previous example shows how a manually created instance can still be initialized. Try to
            prevent creating types manually, by changing the design of those classes. If possible, create a
            single public constructor that only contains dependencies that can be resolved.
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Registers a dynamic (container uncontrolled) collection of elements of type 
            <typeparamref name="TService"/>. A call to <see cref="M:SimpleInjector.Container.GetAllInstances``1"/> will return the 
            <paramref name="collection"/> itself, and updates to the collection will be reflected in the 
            result. If updates are allowed, make sure the collection can be iterated safely if you're running 
            a multi-threaded application.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="collection">The collection to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a <paramref name="collection"/>
            for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="collection"/> is a null
            reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(``0[])">
            <summary>
            Registers a collection of singleton elements of type <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="singletons">The collection to register.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when a <paramref name="singletons"/>
            for <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="singletons"/> is a null
            reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when one of the elements of <paramref name="singletons"/>
            is a null reference.</exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(System.Type[])">
            <summary>
            Registers an collection of <paramref name="serviceTypes"/>, which instances will be resolved when
            enumerating the set returned when a collection of <typeparamref name="TService"/> objects is 
            requested. On enumeration the container is called for each type in the list.
            </summary>
            <typeparam name="TService">The base type or interface for elements in the collection.</typeparam>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null 
            reference (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <typeparamref name="TService"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers a collection of instances of <paramref name="serviceTypes"/> to be returned when
            a collection of <typeparamref name="TService"/> objects is requested.
            </summary>
            <typeparam name="TService">The base type or interface for elements in the collection.</typeparam>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="serviceTypes"/> is a null 
            reference (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <typeparamref name="TService"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers an collection of <paramref name="serviceTypes"/>, which instances will be resolved when
            enumerating the set returned when a collection of <paramref name="serviceType"/> objects is 
            requested. On enumeration the container is called for each type in the list.
            </summary>
            <param name="serviceType">The base type or interface for elements in the collection.</param>
            <param name="serviceTypes">The collection of <see cref="T:System.Type"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null 
            reference (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceTypes"/> contains a null
            (Nothing in VB) element, a generic type definition, or the <paramref name="serviceType"/> is
            not assignable from one of the given <paramref name="serviceTypes"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll(System.Type,System.Collections.Generic.IEnumerable{SimpleInjector.Registration})">
            <summary>
            Registers an collection of <paramref name="registrations"/>, which instances will be resolved when
            enumerating the set returned when a collection of <paramref name="serviceType"/> objects is 
            requested. On enumeration the container is called for each type in the list.
            </summary>
            <param name="serviceType">The base type or interface for elements in the collection.</param>
            <param name="registrations">The collection of <see cref="T:SimpleInjector.Registration"/> objects whose instances
            will be requested from the container.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null 
            reference (Nothing in VB).
            </exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="registrations"/> contains a null
            (Nothing in VB) element, the <paramref name="serviceType"/> is a generic type definition, or when 
            <paramref name="serviceType"/> is
            not assignable from one of the given <paramref name="registrations"/> elements.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.RegisterAll(System.Type,System.Collections.IEnumerable)">
            <summary>
            Registers a dynamic (container uncontrolled) collection of elements of type 
            <paramref name="serviceType"/>. A call to <see cref="M:SimpleInjector.Container.GetAllInstances``1"/> will return the 
            <paramref name="collection"/> itself, and updates to the collection will be reflected in the 
            result. If updates are allowed, make sure the collection can be iterated safely if you're running 
            a multi-threaded application.
            </summary>
            <param name="serviceType">The base type or interface for elements in the collection.</param>
            <param name="collection">The collection of items to register.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null 
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> represents an
            open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Container.Verify">
            <summary>
            Verifies the <b>Container</b>. This method will call all registered delegates, 
            iterate registered collections and throws an exception if there was an error.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the registration of instances was
            invalid.</exception>
        </member>
        <member name="M:SimpleInjector.Container.AddRegistration(System.Type,SimpleInjector.Registration)">
            <summary>
            Adds the <paramref name="registration"/> for the supplied <paramref name="serviceType"/>. This
            method can be used to apply the same <see cref="T:SimpleInjector.Registration"/> to multiple different service
            types.
            </summary>
            <param name="serviceType">The base type or interface to register.</param>
            <param name="registration">The registration that should be stored for the given 
            <paramref name="serviceType"/>.</param>
            <example>
            <code lang="cs"><![CDATA[
            public interface IFoo { }
            public interface IBar { }
            public class FooBar : IFoo, IBar { }
            
            public void AddRegistration_SuppliedWithSameSingletonRegistrationTwice_ReturnsSameInstance()
            {
                // Arrange
                Registration registration =
                    Lifestyle.Singleton.CreateRegistration<FooBar, FooBar>(container);
            
                container.AddRegistration(typeof(IFoo), registration);
                container.AddRegistration(typeof(IBar), registration);
            
                // Act
                IFoo foo = container.GetInstance<IFoo>();
                IBar bar  = container.GetInstance<IBar>();
            
                // Assert
                bool fooAndBareAreTheSameInstance = object.ReferenceEquals(foo, bar);
                Assert.IsTrue(fooAndBareAreTheSameInstance);
            }
            ]]></code>
            <para>
            In the example above a singleton registration is created for type <c>FooBar</c> and this 
            registration is added to the container for each interface (<c>IFoo</c> and <c>IBar</c>) that it
            implements. Since both services use the same singleton registration, requesting those services 
            will result in the return of the same (singleton) instance.
            </para>
            <para>
            <see cref="E:SimpleInjector.Container.ExpressionBuilding"/> events are applied to the <see cref="T:System.Linq.Expressions.Expression"/> of the
            <see cref="T:SimpleInjector.Registration"/> instance and are therefore applied once. <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> 
            events on the other hand get applied to the <b>Expression</b> of the <see cref="T:SimpleInjector.InstanceProducer"/>.
            Since each <b>AddRegistration</b> gets its own instance producer (that wraps the 
            <b>Registration</b> instance), this means that that <b>ExpressionBuilt</b> events will be 
            applied for each registered service type.
            </para>
            <para>
            The most practical example of this is the use of decorators using one of the 
            <see cref="T:SimpleInjector.Extensions.DecoratorExtensions">RegisterDecorator</see> overloads 
            (decorator registration use the
            <b>ExpressionBuilt</b> event under the covers). Take a look at the following example:
            </para>
            <code lang="cs"><![CDATA[
            public interface IFoo { }
            public interface IBar { }
            public class FooBar : IFoo, IBar { }
            
            public class BarDecorator : IBar
            {
                public BarDecorator(IBar decoratedBar)
                {
                    this.DecoratedBar = decoratedBar;
                }
                
                public IBar DecoratedBar { get; private set; }
            }
            
            public void AddRegistration_SameSingletonRegistrationTwiceAndOneDecoratorApplied_ReturnsSameInstance()
            {
                // Arrange
                Registration registration =
                    Lifestyle.Singleton.CreateRegistration<FooBar, FooBar>(container);
            
                container.AddRegistration(typeof(IFoo), registration);
                container.AddRegistration(typeof(IBar), registration);
                
                // Registere a decorator for IBar, but not for IFoo
                container.RegisterDecorator(typeof(IBar), typeof(BarDecorator));
            
                // Act
                var foo = container.GetInstance<IFoo>();
                var decorator = container.GetInstance<IBar>() as BarDecorator;
                var bar = decorator.DecoratedBar;
            
                // Assert
                bool fooAndBareAreTheSameInstance = object.ReferenceEquals(foo, bar);
                Assert.IsTrue(fooAndBareAreTheSameInstance);
            }
            ]]></code>
            The example shows that the decorator gets applied to <c>IBar</c> but not to <c>IFoo</c>, but that
            the decorated <c>IBar</c> is still the same instance as the resolved <c>IFoo</c> instance.
            </example>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not a reference
            type, is open generic, is ambiguous, when it is not assignable from the 
            <paramref name="registration"/>'s <see cref="P:SimpleInjector.Registration.ImplementationType">ImplementationType</see>
            or when the supplied <paramref name="registration"/> is created for a different 
            <see cref="T:SimpleInjector.Container"/> instance.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, or when an 
            the <paramref name="serviceType"/> has already been registered.
            </exception>
        </member>
        <member name="M:SimpleInjector.Container.GetInstance``1">
            <summary>Gets an instance of the given <typeparamref name="TService"/>.</summary>
            <typeparam name="TService">Type of object requested.</typeparam>
            <returns>The requested service instance.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetInstance(System.Type)">
            <summary>Gets an instance of the given <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type of object requested.</param>
            <returns>The requested service instance.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetAllInstances``1">
            <summary>
            Gets all instances of the given <typeparamref name="TService"/> currently registered in the container.
            </summary>
            <typeparam name="TService">Type of object requested.</typeparam>
            <returns>A sequence of instances of the requested TService.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.GetAllInstances(System.Type)">
            <summary>
            Gets all instances of the given <paramref name="serviceType"/> currently registered in the container.
            </summary>
            <param name="serviceType">Type of object requested.</param>
            <returns>A sequence of instances of the requested serviceType.</returns>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when there are errors resolving the service instance.</exception>
        </member>
        <member name="M:SimpleInjector.Container.System#IServiceProvider#GetService(System.Type)">
            <summary>Gets the service object of the specified type.</summary>
            <param name="serviceType">An object that specifies the type of service object to get.</param>
            <returns>A service object of type serviceType.  -or- null if there is no service object of type 
            <paramref name="serviceType"/>.</returns>
        </member>
        <member name="M:SimpleInjector.Container.GetRegistration(System.Type)">
            <summary>
            Gets the <see cref="T:SimpleInjector.InstanceProducer"/> for the given <paramref name="serviceType"/>. When no
            registration exists, the container will try creating a new producer. A producer can be created
            when the type is a concrete reference type, there is an <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/>
            event registered that acts on that type, or when the service type is an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Otherwise <b>null</b> (Nothing in VB) is returned.
            </summary>
            <remarks>
            <para>
            A call to this method locks the container. No new registrations can't be made after a call to this 
            method.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same 
            <see cref="T:SimpleInjector.InstanceProducer"/> instance for a given <see cref="T:System.Type"/>. It will however either 
            always return <b>null</b> or always return a producer that is able to return the expected instance.
            </para>
            </remarks>
            <param name="serviceType">The <see cref="T:System.Type"/> that the returned instance producer should produce.</param>
            <returns>An <see cref="T:SimpleInjector.InstanceProducer"/> or <b>null</b> (Nothing in VB).</returns>
        </member>
        <member name="M:SimpleInjector.Container.GetRegistration(System.Type,System.Boolean)">
            <summary>
            Gets the <see cref="T:SimpleInjector.InstanceProducer"/> for the given <paramref name="serviceType"/>. When no
            registration exists, the container will try creating a new producer. A producer can be created
            when the type is a concrete reference type, there is an <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/>
            event registered that acts on that type, or when the service type is an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Otherwise <b>null</b> (Nothing in VB) is returned, or an exception is throw when
            <paramref name="throwOnFailure"/> is set to <b>true</b>.
            </summary>
            <remarks>
            <para>
            A call to this method locks the container. No new registrations can't be made after a call to this 
            method.
            </para>
            <para>
            <b>Note:</b> This method is <i>not</i> guaranteed to always return the same 
            <see cref="T:SimpleInjector.InstanceProducer"/> instance for a given <see cref="T:System.Type"/>. It will however either 
            always return <b>null</b> or always return a producer that is able to return the expected instance.
            </para>
            </remarks>
            <param name="serviceType">The <see cref="T:System.Type"/> that the returned instance producer should produce.</param>
            <param name="throwOnFailure">The indication whether the method should return null or throw
            an exception when the type is not registered.</param>
            <returns>An <see cref="T:SimpleInjector.InstanceProducer"/> or <b>null</b> (Nothing in VB).</returns>
        </member>
        <member name="M:SimpleInjector.Container.InjectProperties(System.Object)">
            <summary>
            Injects all public writable properties of the given <paramref name="instance"/> that have a type
            that can be resolved by this container instance.
            </summary>
            <param name="instance">The instance whos properties will be injected.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <paramref name="instance"/> is null (Nothing in VB).</exception>
            <exception cref="T:SimpleInjector.ActivationException">Throw when injecting properties on the given instance
            failed due to security constraints of the sandbox. This can happen when injecting properties
            on an internal type in a Silverlight sandbox, or when running in partial trust.</exception>
        </member>
        <member name="P:SimpleInjector.Container.Options">
            <summary>Gets the container options.</summary>
            <value>The <see cref="T:SimpleInjector.ContainerOptions"/> instance for this container.</value>
        </member>
        <member name="E:SimpleInjector.Container.ResolveUnregisteredType">
             <summary>
             Occurs when an instance of a type is requested that has not been registered explicitly, allowing 
             resolution of unregistered types before the container tries to create the type.
             </summary>
             <remarks>
             <para>
             The <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event is called by the container every time an 
             unregistered type is requested for the first time, allowing a developer to do unregistered type 
             resolution. By calling the 
             <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(SimpleInjector.Registration)">Register</see> method on the
             <see cref="T:SimpleInjector.UnregisteredTypeEventArgs"/>, a <see cref="T:SimpleInjector.Registration"/>, <see cref="T:System.Linq.Expressions.Expression"/> or
             <see cref="T:System.Func`1"/> delegate can be registered allowing the container to retrieve 
             instances of the requested type. This registration is cached and it prevents the 
             <b>ResolveUnregisteredType</b> event from being called again for the same type.
             </para>
             <para>
             When no registered event handled the registration of an unregistered type, the container will try
             to create the type when this type is either concrete or is the <see cref="T:System.Collections.Generic.IEnumerable`1"/>
             interface. Concrete types will be registered with the <see cref="F:SimpleInjector.Lifestyle.Transient">Transient</see>
             lifestyle and <see cref="T:System.Collections.Generic.IEnumerable`1"/> registrations will return an empty collection. When no 
             even handled the registration and the container could not create it, an exception is thrown.
             </para>
             <para>
             <b>Thread-safety:</b> Please note that the container will not ensure that the hooked delegates
             are executed only once. While the calls to <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> for a given type
             are finite (and will in most cases happen just once), a container can call the delegate multiple 
             times and make parallel calls to the delegate. You must make sure that the code can be called 
             multiple times and is thread-safe.
             </para>
             </remarks>
             <example>
             The following example shows the usage of the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> event:
             <code lang="cs"><![CDATA[
             public interface IValidator<T>
             {
                 void Validate(T instance);
             }
            
             // Implementation of the null object pattern.
             public class EmptyValidator<T> : IValidator<T>
             {
                 public void Validate(T instance)
                 {
                     // Does nothing.
                 }
             }
             
             [TestMethod]
             public void TestResolveUnregisteredType()
             {
                 // Arrange
                 var container = new Container();
             
                 // Register an EmptyValidator<T> to be returned when a IValidator<T> is requested:
                 container.ResolveUnregisteredType += (sender, e) =>
                 {
                     if (e.UnregisteredServiceType.IsGenericType &&
                         e.UnregisteredServiceType.GetGenericTypeDefinition() == typeof(IValidator<>))
                     {
                         var validatorType = typeof(EmptyValidator<>).MakeGenericType(
                             e.UnregisteredServiceType.GetGenericArguments());
                 
                         object emptyValidator = container.GetInstance(validatorType);
                 
                         // Register the instance as singleton.
                         e.Register(() => emptyValidator);
                     }
                 };
                 
                 // Act
                 var orderValidator = container.GetInstance<IValidator<Order>>();
                 var customerValidator = container.GetInstance<IValidator<Customer>>();
             
                 // Assert
                 Assert.IsInstanceOfType(orderValidator, typeof(EmptyValidator<Order>));
                 Assert.IsInstanceOfType(customerValidator, typeof(EmptyValidator<Customer>));
             }
             ]]></code>
             <para>
             The example above registers a delegate that is raised every time an unregistered type is requested
             from the container. The delegate checks whether the requested type is a closed generic
             implementation of the <b>IValidator&lt;T&gt;</b> interface (such as 
             <b>IValidator&lt;Order&gt;</b> or <b>IValidator&lt;Customer&gt;</b>). In that case it
             will request the container for a concrete <b>EmptyValidator&lt;T&gt;</b> implementation that
             implements the given 
             <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType">UnregisteredServiceType</see>, and
             registers a delegate that will return this created instance. The <b>e.Register</b> call
             registers the method in the container, preventing the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType"/> from
             being called again for the exact same service type, preventing any performance penalties.
             </para>
             <para>
             Please note that given example is just an uhhmm... example. In the case of the example the
             <b>EmptyValidator&lt;T&gt;</b> can be registered using of the built-in 
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric</see> 
             extension methods instead. These extension methods take care of any given generic type constraint
             and allow the implementation to be integrated into the container's pipeline, which allows
             it to be intercepted using the <see cref="E:SimpleInjector.Container.ExpressionBuilding"/> event and allow any registered
             <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> to be applied.
             </para>
             </example>
        </member>
        <member name="E:SimpleInjector.Container.ExpressionBuilt">
             <summary>
             Occurs after the creation of the <see cref="T:System.Linq.Expressions.Expression"/> of a registered type is complete (the 
             lifestyle has been applied), allowing the created <see cref="T:System.Linq.Expressions.Expression"/> to be wrapped, 
             changed, or replaced. Multiple delegates may handle the same service type.
             </summary>
             <remarks>
             <para>
             The <b>ExpressionBuilt</b> event is called by the container every time an registered type is 
             getting compiled, allowing a developer to change the way the type is created. The delegate that
             hooks to the <b>ExpressionBuilt</b> event, can change the 
             <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> property on the 
             <see cref="T:SimpleInjector.ExpressionBuiltEventArgs"/>, which allows changing the way the type is constructed.
             </para>
             <para>
             <b>Thread-safety:</b> Please note that the container will not ensure that the hooked delegates
             are executed only once per service type. While the calls to <see cref="E:SimpleInjector.Container.ExpressionBuilt"/> for a 
             given type are finite (and will in most cases happen just once), a container can call the delegate 
             multiple times and make parallel calls to the delegate. You must make sure that the code can be 
             called multiple times and is thread-safe.
             </para>
             </remarks>
             <example>
             The following example shows the usage of the <b>ExpressionBuilt</b> event:
             <code lang="cs"><![CDATA[
             public interface IValidator<T>
             {
                 void Validate(T instance);
             }
            
             public interface ILogger
             {
                 void Write(string message);
             }
            
             // Implementation of the decorator pattern.
             public class MonitoringValidator<T> : IValidator<T>
             {
                 private readonly IValidator<T> validator;
                 private readonly ILogger logger;
            
                 public MonitoringValidator(IValidator<T> validator, ILogger logger)
                 {
                     this.validator = validator;
                     this.logger = logger;
                 }
            
                 public void Validate(T instance)
                 {
                     this.logger.Write("Validating " + typeof(T).Name);
                     this.validator.Validate(instance);
                     this.logger.Write("Validated " + typeof(T).Name);
                 }
             }
            
             [TestMethod]
             public void TestExpressionBuilt()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, ConsoleLogger>();
                 container.Register<IValidator<Order>, OrderValidator>();
                 container.Register<IValidator<Customer>, CustomerValidator>();
            
                 // Intercept the creation of IValidator<T> instances and wrap them in a MonitoringValidator<T>:
                 container.ExpressionBuilt += (sender, e) =>
                 {
                     if (e.RegisteredServiceType.IsGenericType &&
                         e.RegisteredServiceType.GetGenericTypeDefinition() == typeof(IValidator<>))
                     {
                         var decoratorType = typeof(MonitoringValidator<>)
                             .MakeGenericType(e.RegisteredServiceType.GetGenericArguments());
            
                         // Wrap the IValidator<T> in a MonitoringValidator<T>.
                         e.Expression = Expression.New(decoratorType.GetConstructors()[0], new Expression[]
                         {
                             e.Expression,
                             container.GetRegistration(typeof(ILogger)).BuildExpression(),
                         });
                     }
                 };
            
                 // Act
                 var orderValidator = container.GetInstance<IValidator<Order>>();
                 var customerValidator = container.GetInstance<IValidator<Customer>>();
            
                 // Assert
                 Assert.IsInstanceOfType(orderValidator, typeof(MonitoringValidator<Order>));
                 Assert.IsInstanceOfType(customerValidator, typeof(MonitoringValidator<Customer>));
             }
             ]]></code>
             <para>
             The example above registers a delegate that is raised every time the container compiles the
             expression for an registered type. The delegate checks whether the requested type is a closed generic
             implementation of the <b>IValidator&lt;T&gt;</b> interface (such as 
             <b>IValidator&lt;Order&gt;</b> or <b>IValidator&lt;Customer&gt;</b>). In that case it
             will changes the current <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> with a new one that creates
             a new <b>MonitoringValidator&lt;T&gt;</b> that takes the current validator (and an <b>ILogger</b>)
             as an dependency.
             </para>
             <para>
             Please note that given example is just an uhhmm... example. In the case of the example the
             <b>MonitoringValidator&lt;T&gt;</b> is a decorator and instead of manually writing this code that
             many limitations, you can use one of the built-in 
             <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterDecorator</see> extension methods instead.
             These extension methods take care of any given generic type constraint, allow to register decorators
             conditionally and allow the decorator to be integrated into the container's pipeline, which allows
             it to be intercepted using the <see cref="E:SimpleInjector.Container.ExpressionBuilding"/> event and allow any registered
             <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> to be applied.
             </para>
             </example>
        </member>
        <member name="E:SimpleInjector.Container.ExpressionBuilding">
            <summary>
            Occurs directly after the creation of the <see cref="T:System.Linq.Expressions.Expression"/> of a registered type is made,
            but before any <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializer</see> and lifestyle specific caching
            has been applied, allowing the created <see cref="T:System.Linq.Expressions.Expression"/> to be altered. Multiple delegates 
            may handle the same service type.
            </summary>
            <remarks>
            <para>
            The <b>ExpressionBuilding</b> event is called by the container every time an registered type is 
            getting compiled, allowing a developer to change the way the type is created. The delegate that
            hooks to the <b>ExpressionBuilding</b> event, can change the 
            <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression"/> property on the 
            <see cref="T:SimpleInjector.ExpressionBuildingEventArgs"/>, which allows changing the way the type is constructed.
            </para>
            <para>
            The exact <see cref="T:System.Linq.Expressions.Expression"/> type supplied depends on the type of registration. 
            Registrations that explicitly supply the implementation type (such as 
            <see cref="M:SimpleInjector.Container.Register``2">Register&lt;TService, TImplementation&gt;()</see>)
            will result in an <see cref="T:System.Linq.Expressions.NewExpression"/>, while registrations that take a delegate (such as
            <see cref="M:SimpleInjector.Container.Register``1(System.Func{``0})">Register&lt;TService&gt;(Func&lt;TService&gt;)</see>)
            will result in an <see cref="T:System.Linq.Expressions.InvocationExpression"/>. Singletons that are passed in using their
            value (<see cref="M:SimpleInjector.Container.RegisterSingle``1(``0)">RegisterSingle&lt;TService&gt;(TService)</see>)
            will result in an <see cref="T:System.Linq.Expressions.ConstantExpression"/>. Note that other <b>ExpressionBuilding</b> 
            registrations might have changed the <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression"/> 
            property and might have supplied an <see cref="T:System.Linq.Expressions.Expression"/> of a different type. The order in
            which these events are registered might be of importantance to you.
            </para>
            <para>
            <b>Thread-safety:</b> Please note that the container will not ensure that the hooked delegates
            are executed only once per service type. While the calls to registered <b>ExpressionBuilding</b>
            events for a  given type are finite (and will in most cases happen just once), a container can 
            call the delegate multiple times and make parallel calls to the delegate. You must make sure that 
            the code can be called multiple times and is thread-safe.
            </para>
            </remarks>
            <example>
            The following example shows the usage of the <b>ExpressionBuilding</b> event:
            <code lang="cs"><![CDATA[
            public class MyInjectPropertyAttribute : Attribute { }
            
            public static void Bootstrap()
            {
                var container = new Container();
                
                container.ExpressionBuilding += (sender, e) =>
                {
                    var expression = e.Expression as NewExpression;
                
                    if (expression != null)
                    {
                        var propertiesToInject =
                            from property in expression.Constructor.DeclaringType.GetProperties()
                            where property.GetCustomAttributes(typeof(MyInjectPropertyAttribute), true).Any()
                            let registration = container.GetRegistration(property.PropertyType, true)
                            select Tuple.Create(property, registration);
                
                        if (propertiesToInject.Any())
                        {
                            Func<object, Tuple<PropertyInfo, InstanceProducer>[], object> injectorDelegate =
                                (instance, dependencies) =>
                                {
                                    foreach (var dependency in dependencies)
                                    {
                                        dependency.Item1.SetValue(instance, dependency.Item2.GetInstance(), null);
                                    }
                
                                    return instance;
                                };
                
                            e.Expression = Expression.Convert(
                                Expression.Invoke(
                                    Expression.Constant(injectorDelegate),
                                    e.Expression,
                                    Expression.Constant(propertiesToInject.ToArray())),
                                expression.Constructor.DeclaringType);
                        }
                    }
                };
            }
            ]]></code>
            <para>
            The example above registers a delegate that is raised every time the container compiles the
            expression for an registered type. The delegate checks if the type contains properties that are
            decorated with the supplied <b>MyInjectPropertyAttribute</b>. If decorated properties are found,
            the given expression is replaced with an expression that injects decorated properties.
            </para>
            <para>
            The example differs from the container's built-in <see cref="M:SimpleInjector.Container.InjectProperties(System.Object)"/> method in that
            it will fail when one of the decorated properties can not be injected. The built-in
            <see cref="M:SimpleInjector.Container.InjectProperties(System.Object)"/> will look at all properties of a given class and will simply skip
            over any properties that can not be injected, making the use of the <see cref="M:SimpleInjector.Container.InjectProperties(System.Object)"/>
            method often verify fragile and error prone.
            </para>
            </example>
        </member>
        <member name="T:SimpleInjector.Container.InstanceInitializer">
            <summary>Wrapper for instance initializer Action delegates.</summary>
        </member>
        <member name="T:SimpleInjector.ContainerOptions">
            <summary>Configuration options for the <see cref="P:SimpleInjector.ContainerOptions.Container"/>.</summary>
            <example>
            The following example shows the typical usage of the <b>ContainerOptions</b> class.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            container.Register<ITimeProvider, DefaultTimeProvider>();
            
            // Use of ContainerOptions clas here.
            container.Options.AllowOverridingRegistrations = true;
            
            // Replaces the previous registration of ITimeProvider
            container.Register<ITimeProvider, CustomTimeProvider>();
            ]]></code>
            </example>
        </member>
        <member name="M:SimpleInjector.ContainerOptions.#ctor">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.ContainerOptions"/> class.</summary>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.AllowOverridingRegistrations">
            <summary>
            Gets or sets a value indicating whether the container allows overriding registrations. The default
            is false.
            </summary>
            <value>The value indicating whether the container allows overriding registrations.</value>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorResolutionBehavior">
            <summary>Gets or sets the constructor resolution behavior.</summary>
            <value>The constructor resolution behavior.</value>
            <exception cref="T:System.NullReferenceException">Thrown when the supplied value is a null reference.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the container already contains registrations.
            </exception>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorVerificationBehavior">
            <summary>Gets or sets the constructor resolution behavior.</summary>
            <value>The constructor resolution behavior.</value>
            <exception cref="T:System.NullReferenceException">Thrown when the supplied value is a null reference.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the container already contains registrations.
            </exception>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.ConstructorInjectionBehavior">
            <summary>Gets or sets the constructor injection behavior.</summary>
            <value>The constructor injection behavior.</value>
            <exception cref="T:System.NullReferenceException">Thrown when the supplied value is a null reference.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the container already contains registrations.
            </exception>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.PropertySelectionBehavior">
            <summary>Gets or sets the property selection behavior.</summary>
            <value>The property selection behavior.</value>
            <exception cref="T:System.NullReferenceException">Thrown when the supplied value is a null reference.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the container already contains registrations.
            </exception>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.Container">
            <summary>
            Gets the container to which this <b>ContainerOptions</b> instance belongs to or <b>null</b> when
            this instance hasn't been applied to a <see cref="P:SimpleInjector.ContainerOptions.Container"/> yet.
            </summary>
            <value>The current <see cref="P:SimpleInjector.ContainerOptions.Container"/>.</value>
        </member>
        <member name="P:SimpleInjector.ContainerOptions.EnableDynamicAssemblyCompilation">
            <summary>
            Gets or sets a value indicating whether the container will use dynamic assemblies for compilation. 
            By default, this value is <b>true</b> for the first few containers that are created in an app 
            domain and <b>false</b> for all other containers. You can set this value explicitly to <b>false</b>
            to prevent the use of dynamic assemblies or you can set this value explicitly to <b>true</b> to
            force more container instances to use dynamic assemblies. Note that creating an infinite number
            of <see cref="P:SimpleInjector.ContainerOptions.Container"/> instances (for instance one per web request) with this property set to
            <b>true</b> will result in a memory leak; dynamic assemblies take up memory and will only be
            unloaded when the app domain is unloaded.
            </summary>
            <value>A boolean indicating whether the container should use a dynamic assembly for compilation.
            </value>
        </member>
        <member name="T:SimpleInjector.CyclicDependencyValidator">
            <summary>
            Allows verifying whether a given type has a direct or indirect dependency on itself. Verifying is done
            by preventing recursive calls to a IInstanceProvider. An instance of this type is related to a single 
            instance of a IInstanceProvider. A RecursiveDependencyValidator instance checks a single 
            IInstanceProvider and therefore a single service type.
            </summary>
        </member>
        <member name="T:SimpleInjector.CyclicDependencyValidatorExtensions">
            <summary>
            Extension methods for the RecursiveDependencyValidator class.
            </summary>
        </member>
        <member name="T:SimpleInjector.ExpressionBuildingEventArgs">
            <summary>
            Provides data for and interaction with the 
            <see cref="E:SimpleInjector.Container.ExpressionBuilding">ExpressionBuilding</see> event of 
            the <see cref="T:SimpleInjector.Container"/>. An observer can change the 
            <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression"/> property to change the component that is 
            currently being built.
            </summary>
        </member>
        <member name="P:SimpleInjector.ExpressionBuildingEventArgs.RegisteredServiceType">
            <summary>Gets the registered service type that is currently requested.</summary>
            <value>The registered service type that is currently requested.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuildingEventArgs.KnownImplementationType">
            <summary>
            Gets the type that is known to be returned by the 
            <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression">Expression</see> (most often the implementation
            type used in the <b>Register</b> call). This type will be a derivative of
            <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.RegisteredServiceType">RegisteredServiceType</see> (or
            or <b>RegisteredServiceType</b> itself). If the <b>Expression</b> is changed, the new expression 
            must also return an instance of type <b>KnownImplementationType</b> or a sub type. 
            This information must be described in the new Expression.
            </summary>
            <value>A <see cref="T:System.Type"/>.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuildingEventArgs.Lifestyle">
            <summary>
            Gets the lifestyle for the component that is currently being built.
            </summary>
            <value>The <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Lifestyle"/>.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuildingEventArgs.Expression">
            <summary>Gets or sets the currently registered <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression"/>.</summary>
            <value>The current registration.</value>
            <exception cref="T:System.ArgumentNullException">Thrown when the supplied value is a null reference.</exception>
        </member>
        <member name="P:SimpleInjector.ExpressionBuildingEventArgs.KnownRelationships">
            <summary>
            Gets the collection of currently known relationships. This information is used by the Diagnostics 
            Debug View. Change the contents of this collection to represent the changes made to the
            <see cref="P:SimpleInjector.ExpressionBuildingEventArgs.Expression">Expression</see> property (if any). This allows
            the Diagnostics Debug View to analyse those new relationships as well.
            </summary>
            <value>The collection of <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> instances.</value>
        </member>
        <member name="T:SimpleInjector.ExpressionBuiltEventArgs">
            <summary>
            Provides data for and interaction with the 
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event of 
            the <see cref="T:SimpleInjector.Container"/>. An observer can change the 
            <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/> property to change the component that is currently 
            being built. 
            </summary>
        </member>
        <member name="M:SimpleInjector.ExpressionBuiltEventArgs.#ctor(System.Type,System.Linq.Expressions.Expression)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.ExpressionBuiltEventArgs"/> class.</summary>
            <param name="registeredServiceType">Type of the registered service.</param>
            <param name="expression">The registered expression.</param>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.RegisteredServiceType">
            <summary>Gets the registered service type that is currently requested.</summary>
            <value>The registered service type that is currently requested.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.Expression">
            <summary>Gets or sets the currently registered <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression"/>.</summary>
            <value>The current registration.</value>
            <exception cref="T:System.ArgumentNullException">Thrown when the supplied value is a null reference.</exception>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.Lifestyle">
            <summary>Gets or sets the current lifestyle of the registration.</summary>
            <value>The original lifestyle of the registration.</value>
        </member>
        <member name="P:SimpleInjector.ExpressionBuiltEventArgs.KnownRelationships">
            <summary>
            Gets the collection of currently known relationships. This information is used by the Diagnostics 
            Debug View. Change the contents of this collection to represent the changes made to the
            <see cref="P:SimpleInjector.ExpressionBuiltEventArgs.Expression">Expression</see> property (if any). This allows
            the Diagnostics Debug View to analyse those new relationships as well.
            </summary>
            <value>The collection of <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> instances.</value>
        </member>
        <member name="T:SimpleInjector.Extensions.DecoratorExtensions">
            <summary>
            Extension methods for applying decorators.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">
            <summary>
            Ensures that the supplied <paramref name="decoratorType"/> decorator is returned and cached with
            the given <paramref name="lifestyle"/>, wrapping the original registered 
            <paramref name="serviceType"/>, by injecting that service type into the constructor of the 
            supplied <paramref name="decoratorType"/>. Multiple decorators may be applied to the same 
            <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and non-generic 
            service types.
            </summary>
            <remarks>
            <para>
            The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
            <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
            decoration of types that are resolved using unregistered type resolution. The
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric</see>
            extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
            use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
            </para>
            <para>
            Multiple decorators can be applied to the same service type. The order in which they are registered
            is the order they get applied in. This means that the decorator that gets registered first, gets
            applied first, which means that the next registered decorator, will wrap the first decorator, which
            wraps the original service type.
            </para>
            <para>
            Constructor injection will be used on that type, and although it may have many constructor 
            arguments, it must have exactly one argument of the type of <paramref name="serviceType"/>, or an 
            argument of type <see cref="T:System.Func`1"/> where <b>TResult</b> is <paramref name="serviceType"/>.
            An exception will be thrown when this is not the case.
            </para>
            <para>
            The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
            <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, the
            will not inject the decorated <paramref name="serviceType"/> itself into the 
            <paramref name="decoratorType"/> instance, but it will inject a <see cref="T:System.Func`1"/> that allows
            creating instances of the decorated type, according to the lifestyle of that type. This enables
            more advanced scenarios, such as executing the decorated types on a different thread, or executing
            decorated instance within a certain scope (such as a lifetime scope).
            </para>
            </remarks>
            <example>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned decorator will be cached.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
            implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
            does not have a single public constructor, or when <paramref name="decoratorType"/> does 
            not contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">
            <summary>
            Ensures that the supplied <paramref name="decoratorType"/> decorator is returned when the supplied
            <paramref name="predicate"/> returns <b>true</b> and cached with the given 
            <paramref name="lifestyle"/>, wrapping the original registered <paramref name="serviceType"/>, by 
            injecting that service type into the constructor of the supplied <paramref name="decoratorType"/>. 
            Multiple decorators may be applied to the same <paramref name="serviceType"/>. Decorators can be 
            applied to both open, closed, and non-generic service types.
            </summary>
            <remarks>
            <para>
            The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
            <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
            decoration of types that are resolved using unregistered type resolution. The
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric</see>
            extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
            use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
            </para>
            <para>
            Multiple decorators can be applied to the same service type. The order in which they are registered
            is the order they get applied in. This means that the decorator that gets registered first, gets
            applied first, which means that the next registered decorator, will wrap the first decorator, which
            wraps the original service type.
            </para>
            <para>
            Constructor injection will be used on that type, and although it may have many constructor 
            arguments, it must have exactly one argument of the type of <paramref name="serviceType"/>, or an 
            argument of type <see cref="T:System.Func`1"/> where <b>TResult</b> is <paramref name="serviceType"/>.
            An exception will be thrown when this is not the case.
            </para>
            <para>
            The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
            <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, the
            will not inject the decorated <paramref name="serviceType"/> itself into the 
            <paramref name="decoratorType"/> instance, but it will inject a <see cref="T:System.Func`1"/> that allows
            creating instances of the decorated type, according to the lifestyle of that type. This enables
            more advanced scenarios, such as executing the decorated types on a different thread, or executing
            decorated instance within a certain scope (such as a lifetime scope).
            </para>
            </remarks>
            <example>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned decorator will be cached.</param>
            <param name="predicate">The predicate that determines whether the 
            <paramref name="decoratorType"/> must be applied to a service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
            implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
            does not have a single public constructor, or when <paramref name="decoratorType"/> does 
            not contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">
             <summary>
             Ensures that the supplied <paramref name="decoratorType"/> decorator is returned, wrapping the 
             original registered <paramref name="serviceType"/>, by injecting that service type into the 
             constructor of the supplied <paramref name="decoratorType"/>. Multiple decorators may be applied 
             to the same <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and 
             non-generic service types. A new <paramref name="decoratorType"/> will always be returned (the
             <see cref="F:SimpleInjector.Lifestyle.Transient">Transient</see> lifestyle), independently of the lifestyle of the 
             wrapped service.
             </summary>
             <remarks>
             <para>
             The <b>RegisterDecorator</b> method works by hooking onto the container's
             <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
             <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
             decoration of types that are resolved using unregistered type resolution. The
             <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric</see>
             extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
             use <b>RegisterDecorator</b> on the same generic service type as <b>RegisterOpenGeneric</b>.
             </para>
             <para>
             Multiple decorators can be applied to the same service type. The order in which they are registered
             is the order they get applied in. This means that the decorator that gets registered first, gets
             applied first, which means that the next registered decorator, will wrap the first decorator, which
             wraps the original service type.
             </para>
             <para>
             Constructor injection will be used on that type, and although it may have many constructor 
             arguments, it must have exactly one argument of the type of <paramref name="serviceType"/>, or an 
             argument of type <see cref="T:System.Func`1"/> where <b>TResult</b> is <paramref name="serviceType"/>.
             An exception will be thrown when this is not the case.
             </para>
             <para>
             The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
             <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, an decorated
             instance will not injected into the <paramref name="decoratorType"/>, but it will inject a 
             <see cref="T:System.Func`1"/> that allows creating instances of the decorated type, according to the
             lifestyle of that type. This enables more advanced scenarios, such as executing the decorated 
             types on a different thread, or executing decorated instance within a certain scope (such as a 
             lifetime scope).
             </para>
             </remarks>
             <example>
             The following example shows the definition of a generic <b>ICommandHandler&lt;T&gt;</b> interface,
             a <b>CustomerMovedCommandHandler</b> implementing that interface, and a 
             <b>ValidatorCommandHandlerDecorator&lt;T&gt;</b> that acts as a decorator for that interface.
             <code lang="cs"><![CDATA[
             using System.ComponentModel.DataAnnotations;
             using System.Diagnostics;
             using System.Linq;
             
             using Microsoft.VisualStudio.TestTools.UnitTesting;
             
             using SimpleInjector;
             using SimpleInjector.Extensions;
             
             public interface ICommandHandler<TCommand>
             {
                 void Handle(TCommand command);
             }
            
             public class CustomerMovedCommand
             {
                 [Required]
                 public int CustomerId { get; set; }
            
                 [Required]
                 public Address Address { get; set; }
             }
            
             public class CustomerMovedCommandHandler
                 : ICommandHandler<CustomerMovedCommand>
             {
                 public void Handle(CustomerMovedCommand command)
                 {
                     // some logic
                 }
             }
            
             // Decorator that validates commands before they get executed.
             public class ValidatorCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly Container container;
            
                 public ValidatorCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     Container container)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.container = container;
                 }
            
                 public void Handle(TCommand command)
                 {
                     this.Validate(command);
            
                     this.decoratedHandler.Handle(command);
                 }
            
                 private void Validate(TCommand command)
                 {
                     var validationContext =
                         new ValidationContext(command, this.container, null);
            
                     Validator.ValidateObject(command, validationContext);
                 }
             }
             
             // Decorator that measures the time it takes to execute a command.
             public class MonitoringCommandHandlerDecorator<TCommand>
                 : ICommandHandler<TCommand>
             {
                 private readonly ICommandHandler<TCommand> decoratedHandler;
                 private readonly ILogger logger;
            
                 public MonitoringCommandHandlerDecorator(
                     ICommandHandler<TCommand> decoratedHandler,
                     ILogger logger)
                 {
                     this.decoratedHandler = decoratedHandler;
                     this.logger = logger;
                 }
            
                 public void Handle(TCommand command)
                 {
                     var watch = Stopwatch.StartNew();
            
                     this.decoratedHandler.Handle(command);
            
                     this.logger.Log(string.Format("{0} executed in {1} ms.",
                         command.GetType().Name, watch.ElapsedMilliseconds));
                 }
             }
             
             [TestMethod]
             public static void TestRegisterOpenGenericDecorator()
             {
                 // Arrange
                 var container = new Container();
            
                 container.RegisterSingle<ILogger, DebugLogger>();
            
                 // Search the given assembly and register all concrete types that 
                 // implement ICommandHandler<TCommand>.
                 container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>),
                     typeof(ICommandHandler<>).Assembly);
            
                 // Wrap all ICommandHandler<TCommand> service types with a decorator
                 // that measures and logs the duration of that handler.
                 container.RegisterDecorator(typeof(ICommandHandler<>),
                     typeof(MonitoringCommandHandlerDecorator<>));
            
                 // Wrap all ICommandHandler<TCommand> types (in this case it will
                 // wrap the monitoring decorator), but only if the TCommand contains
                 // any properties.
                 container.RegisterDecorator(typeof(ICommandHandler<>),
                     typeof(ValidatorCommandHandlerDecorator<>), context =>
                     {
                         var commandType = context.ServiceType.GetGenericArguments()[0];
                         bool mustDecorate = commandType.GetProperties().Any();
                         return mustDecorate;
                     });
            
                 // Act
                 var handler = 
                     container.GetInstance<ICommandHandler<CustomerMovedCommand>>();
            
                 // Assert
                 Assert.IsInstanceOfType(handler, 
                     typeof(ValidatorCommandHandlerDecorator<CustomerMovedCommand>));
             }
             ]]></code>
             </example>
             <param name="container">The container to make the registrations in.</param>
             <param name="serviceType">The definition of the open generic service type that will
             be wrapped by the given <paramref name="decoratorType"/>.</param>
             <param name="decoratorType">The definition of the open generic decorator type that will
             be used to wrap the original service type.</param>
             <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
             <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/>  is not
             an open generic type, when <paramref name="decoratorType"/> does not inherit from or implement 
             <paramref name="serviceType"/>, when <paramref name="decoratorType"/> does not
             have a single public constructor, or when <paramref name="decoratorType"/> does not
             contain a constructor that has exactly one argument of type 
             <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
             <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">
            <summary>
            Ensures that the supplied <paramref name="decoratorType"/> decorator is returned when the supplied
            <paramref name="predicate"/> returns <b>true</b>, wrapping the original registered 
            <paramref name="serviceType"/>, by injecting that service type into the constructor of the 
            supplied <paramref name="decoratorType"/>. Multiple decorators may be applied to the same 
            <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and non-generic 
            service types. A new <paramref name="decoratorType"/> will always be returned (the
            <see cref="F:SimpleInjector.Lifestyle.Transient">Transient</see> lifestyle), independently of the lifestyle of the 
            wrapped service.
            </summary>
            <remarks>
            <para>
            The <b>RegisterOpenGenericDecorator</b> method works by hooking onto the container's
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> event. This event fires after the
            <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event, which allows
            decoration of types that are resolved using unregistered type resolution. The
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric</see>
            extension method, for instance, hooks onto the <b>ResolveUnregisteredType</b>. This allows you to
            use <b>RegisterOpenGenericDecorator</b> on the same service type as <b>RegisterOpenGeneric</b>.
            </para>
            <para>
            Multiple decorators can be applied to the same service type. The order in which they are registered
            is the order they get applied in. This means that the decorator that gets registered first, gets
            applied first, which means that the next registered decorator, will wrap the first decorator, which
            wraps the original service type.
            </para>
            <para>
            Constructor injection will be used on that type, and although it may have many constructor 
            arguments, it must have exactly one argument of the type of <paramref name="serviceType"/>, or an 
            argument of type <see cref="T:System.Func`1"/> where <b>TResult</b> is <paramref name="serviceType"/>.
            An exception will be thrown when this is not the case.
            </para>
            <para>
            The registered <paramref name="decoratorType"/> may have a constructor with an argument of type
            <see cref="T:System.Func`1"/> where <b>T</b> is <paramref name="serviceType"/>. In this case, the
            will not inject the decorated <paramref name="serviceType"/> itself into the 
            <paramref name="decoratorType"/> instance, but it will inject a <see cref="T:System.Func`1"/> that allows
            creating instances of the decorated type, according to the lifestyle of that type. This enables
            more advanced scenarios, such as executing the decorated types on a different thread, or executing
            decorated instance within a certain scope (such as a lifetime scope).
            </para>
            </remarks>
            <example>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <param name="predicate">The predicate that determines whether the 
            <paramref name="decoratorType"/> must be applied to a service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
            implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
            does not have a single public constructor, or when <paramref name="decoratorType"/> does 
            not contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterSingleDecorator(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Ensures that a single instance of the supplied <paramref name="decoratorType"/> decorator is 
            returned, wrapping the original registered <paramref name="serviceType"/>, by injecting that 
            service type into the constructor of the supplied <paramref name="decoratorType"/>. Multiple 
            decorators may be applied to the same <paramref name="serviceType"/>. Decorators can be applied 
            to both open, closed, and non-generic service types.
            </summary>
            <remarks>
            <para>
            This method ensures that a single instance of the supplied <paramref name="decoratorType"/> is
            returned, no matter what the lifestyle of the wrapped service type is. Use with care, because the
            wrapped service type will also become a singleton. This method is especially useful when use for
            injecting <see cref="T:System.Func`1"/> factory methods, which will allow the wrapped service type to get
            it's own lifestyle back.
            </para>
            </remarks>
            <example>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/>  is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or implement 
            <paramref name="serviceType"/>, when <paramref name="decoratorType"/> does not
            have a single public constructor, or when <paramref name="decoratorType"/> does not
            contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterSingleDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">
            <summary>
            Ensures that the supplied <paramref name="decoratorType"/> decorator is returned when the supplied
            <paramref name="predicate"/> returns <b>true</b>, wrapping the original registered 
            <paramref name="serviceType"/>, by injecting that service type into the constructor of the 
            supplied <paramref name="decoratorType"/>. Multiple decorators may be applied to the same 
            <paramref name="serviceType"/>. Decorators can be applied to both open, closed, and non-generic 
            service types.
            </summary>
            <remarks>
            <para>
            This method ensures that a single instance of the supplied <paramref name="decoratorType"/> is
            returned, no matter what the lifestyle of the wrapped service type is. Use with care, because the
            wrapped service type will also become a singleton. This method is especially useful when use for
            injecting <see cref="T:System.Func`1"/> factory methods, which will allow the wrapped service type to get
            it's own lifestyle back.
            </para>
            </remarks>
            <example>
            Please see the <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type)">RegisterDecorator</see> method
            for more information.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="serviceType">The definition of the open generic service type that will
            be wrapped by the given <paramref name="decoratorType"/>.</param>
            <param name="decoratorType">The definition of the open generic decorator type that will
            be used to wrap the original service type.</param>
            <param name="predicate">The predicate that determines whether the 
            <paramref name="decoratorType"/> must be applied to a service type.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="serviceType"/> is not
            an open generic type, when <paramref name="decoratorType"/> does not inherit from or 
            implement <paramref name="serviceType"/>, when <paramref name="decoratorType"/>
            does not have a single public constructor, or when <paramref name="decoratorType"/> does 
            not contain a constructor that has exactly one argument of type 
            <paramref name="serviceType"/> or <see cref="T:System.Func`1"/> where <b>T</b> is
            <paramref name="serviceType"/>.</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.DecoratorPredicateContext">
            <summary>
            An instance of this type will be supplied to the <see cref="T:System.Predicate`1"/>
            delegate that is that is supplied to the 
            <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">RegisterDecorator</see>
            overload that takes this delegate. This type contains information about the decoration that is about
            to be applied and it allows users to examine the given instance to see whether the decorator should
            be applied or not.
            </summary>
            <remarks>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.DecoratorExtensions.RegisterDecorator(SimpleInjector.Container,System.Type,System.Type,System.Predicate{SimpleInjector.Extensions.DecoratorPredicateContext})">RegisterDecorator</see>
            method for more information.
            </remarks>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.ServiceType">
            <summary>
            Gets the closed generic service type for which the decorator is about to be applied. The original
            service type will be returned, even if other decorators have already been applied to this type.
            </summary>
            <value>The closed generic service type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.ImplementationType">
            <summary>
            Gets the type of the implementation that is created by the container and for which the decorator
            is about to be applied. The original implementation type will be returned, even if other decorators
            have already been applied to this type. Please not that the implementation type can not always be
            determined. In that case the closed generic service type will be returned.
            </summary>
            <value>The implementation type.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.AppliedDecorators">
            <summary>
            Gets the list of the types of decorators that have already been applied to this instance.
            </summary>
            <value>The applied decorators.</value>
        </member>
        <member name="P:SimpleInjector.Extensions.DecoratorPredicateContext.Expression">
            <summary>
            Gets the current <see cref="P:SimpleInjector.Extensions.DecoratorPredicateContext.Expression"/> object that describes the intention to create a new
            instance with its currently applied decorators.
            </summary>
            <value>The current expression that is about to be decorated.</value>
        </member>
        <member name="T:SimpleInjector.Extensions.Decorators.DecoratorExpressionInterceptor">
            <summary>
            Hooks into the building process and adds a decorator if needed.
            </summary>
        </member>
        <member name="T:SimpleInjector.Registration">
            <summary>
            A <b>Registration</b> implements lifestyle based caching for a single service.
            </summary>
            <remarks>
            <see cref="P:SimpleInjector.Registration.Lifestyle"/> implementations create a new <b>Registration</b> instance for each registered
            service type. <see cref="T:System.Linq.Expressions.Expression"/>s returned from the 
            <see cref="M:SimpleInjector.Registration.BuildExpression">BuildExpression</see> method can be intercepted by any event
            registered with <see cref="E:SimpleInjector.Container.ExpressionBuilding"/>, have 
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> applied, and the caching 
            particular to its lifestyle have been applied. Interception using the 
            <see cref="E:SimpleInjector.Container.ExpressionBuilt">Container.ExpressionBuilt</see> will <b>not</b> 
            be applied.</remarks>
            <example>
            See the <see cref="P:SimpleInjector.Registration.Lifestyle"/> documentation for an example.
            </example>
        </member>
        <member name="M:SimpleInjector.Registration.#ctor(SimpleInjector.Lifestyle,SimpleInjector.Container)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.Registration"/> class.
            </summary>
            <param name="lifestyle">The <see cref="P:SimpleInjector.Registration.Lifestyle"/> this that created this registration.</param>
            <param name="container">The <see cref="P:SimpleInjector.Registration.Container"/> instance for this registration.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Registration.BuildExpression">
            <summary>
            Builds a new <see cref="T:System.Linq.Expressions.Expression"/> with the correct caching (according to the specifications of
            its <see cref="P:SimpleInjector.Registration.Lifestyle"/>) applied.
            </summary>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/>.</returns>
        </member>
        <member name="M:SimpleInjector.Registration.GetRelationships">
            <summary>
            Gets the list of <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> instances. Note that the list is only available
            after calling <see cref="M:SimpleInjector.Registration.BuildExpression"/>.
            </summary>
            <returns>A new array containing the <see cref="T:SimpleInjector.Advanced.KnownRelationship"/> instances.</returns>
        </member>
        <member name="M:SimpleInjector.Registration.InitializeInstance(System.Object)">
            <summary>
            Initializes an already created instance and applies properties and initializers to that instance.
            </summary>
            <remarks>
            This method is especially useful in integration scenarios where the given platform is in control
            of creating certain types. By passing the instance created by the platform to this method, the
            container is still able to apply any properties (as defined using a custom
            <see cref="T:SimpleInjector.Advanced.IPropertySelectionBehavior"/>) and by applying any initializers.
            </remarks>
            <param name="instance">The instance to initialize.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="instance"/> is a null reference
            (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when the supplied <paramref name="instance"/> is not
            of type <see cref="P:SimpleInjector.Registration.ImplementationType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Registration.BuildTransientDelegate``1(System.Func{``0})">
            <summary>
            Builds a <see cref="T:System.Func`1"/> delegate for the creation of the <typeparamref name="TService"/>
            using the supplied <paramref name="instanceCreator"/>. The returned <see cref="T:System.Func`1"/> might
            be intercepted by a 
            <see cref="E:SimpleInjector.Container.ExpressionBuilding">Container.ExpressionBuilding</see> event, 
            and the <paramref name="instanceCreator"/> will have been wrapped with a delegate that executes the
            registered <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> that are 
            appliable to the given <typeparamref name="TService"/> (if any).
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">
            The delegate supplied by the user that allows building or creating new instances.</param>
            <returns>A <see cref="T:System.Func`1"/> delegate.</returns>
        </member>
        <member name="M:SimpleInjector.Registration.BuildTransientDelegate``2">
            <summary>
            Builds a <see cref="T:System.Func`1"/> delegate for the creation of <typeparamref name="TImplementation"/>.
            The returned <see cref="T:System.Func`1"/> might be intercepted by a 
            <see cref="E:SimpleInjector.Container.ExpressionBuilding">Container.ExpressionBuilding</see> event, 
            and the creation of the <typeparamref name="TImplementation"/> will have been wrapped with a 
            delegate that executes the registered 
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> 
            that are appliable to the given <typeparamref name="TService"/> (if any).
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <returns>A <see cref="T:System.Func`1"/> delegate.</returns>
        </member>
        <member name="M:SimpleInjector.Registration.BuildTransientExpression``1(System.Func{``0})">
            <summary>
            Builds an <see cref="T:System.Linq.Expressions.Expression"/> that describes the creation of the <typeparamref name="TService"/>
            using the supplied <paramref name="instanceCreator"/>. The returned <see cref="T:System.Linq.Expressions.Expression"/> might
            be intercepted by a 
            <see cref="E:SimpleInjector.Container.ExpressionBuilding">Container.ExpressionBuilding</see> event, 
            and the <paramref name="instanceCreator"/> will have been wrapped with a delegate that executes the
            registered <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> that are 
            appliable to the given <typeparamref name="TService"/> (if any).
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="instanceCreator">
            The delegate supplied by the user that allows building or creating new instances.</param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/>.</returns>
        </member>
        <member name="M:SimpleInjector.Registration.BuildTransientExpression``2">
            <summary>
            Builds an <see cref="T:System.Linq.Expressions.Expression"/> that describes the creation of 
            <typeparamref name="TImplementation"/>. The returned <see cref="T:System.Linq.Expressions.Expression"/> might be intercepted
            by a <see cref="E:SimpleInjector.Container.ExpressionBuilding">Container.ExpressionBuilding</see>
            event, and the creation of the <typeparamref name="TImplementation"/> will have been wrapped with
            a delegate that executes the registered 
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> 
            that are appliable to the given <typeparamref name="TService"/> (if any).
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <returns>An <see cref="T:System.Linq.Expressions.Expression"/>.</returns>
        </member>
        <member name="P:SimpleInjector.Registration.ImplementationType">
            <summary>
            Gets the type that this instance will create.
            </summary>
            <value>The type that this instance will create.</value>
        </member>
        <member name="P:SimpleInjector.Registration.Lifestyle">
            <summary>
            Gets the <see cref="P:SimpleInjector.Registration.Lifestyle"/> this that created this registration.
            </summary>
            <value>The <see cref="P:SimpleInjector.Registration.Lifestyle"/> this that created this registration.</value>
        </member>
        <member name="P:SimpleInjector.Registration.Container">
            <summary>
            Gets the <see cref="P:SimpleInjector.Registration.Container"/> instance for this registration.
            </summary>
            <value>The <see cref="P:SimpleInjector.Registration.Container"/> instance for this registration.</value>
        </member>
        <member name="T:SimpleInjector.Extensions.ExtensionHelpers">
            <summary>
            Helper methods for the extensions.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericArgumentFinder">
            <summary>
            Allows retrieving the concrete types of the generic type arguments of that must be used to create a
            closed generic implementation of a given open generic implementation, based on on the concrete
            arguments of the given closed base type.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping">
            <summary>
            A map containing a generic argument (such as T) and the concrete type (such as Int32) that it
            represents.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping.System#IEquatable{SimpleInjector#Extensions#GenericArgumentFinder#ArgumentMapping}#Equals(SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping)">
            <summary>Implements equality. Needed for doing LINQ distinct operations.</summary>
            <param name="other">The other to compare to.</param>
            <returns>True or false.</returns>
        </member>
        <member name="M:SimpleInjector.Extensions.GenericArgumentFinder.ArgumentMapping.GetHashCode">
            <summary>Overrides the default hash code. Needed for doing LINQ distinct operations.</summary>
            <returns>An 32 bit integer.</returns>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericTypeBuilder">
            <summary>
            Helper class for building closed generic type for a given open generic type and a closed generic base.
            </summary>
        </member>
        <member name="T:SimpleInjector.Extensions.GenericTypeBuilder.BuildResult">
            <summary>Result of the GenericTypeBuilder.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.BatchRegistrationCallback">
            <summary>
            Represents the method that will called to register one or multiple concrete non-generic
            <paramref name="implementations"/> of the given closed generic type 
            <paramref name="closedServiceType"/>.
            </summary>
            <param name="closedServiceType">The service type that needs to be registered.</param>
            <param name="implementations">One or more concrete types that implement the given 
            <paramref name="closedServiceType"/>.</param>
            <example>
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            BatchRegistrationCallback registerAsCollectionAsSingletons = (closedServiceType, implementations) =>
            {
                foreach (Type implementation in implementations)
                {
                    container.RegisterSingle(implementation);
                }
                
                container.RegisterAll(closedServiceType, implementations);
            };
            
            container.RegisterManyForOpenGeneric(
                typeof(ICommandHandler<>),
                registerAsCollectionAsSingletons, 
                typeof(ICommandHandler<>).Assembly);
            ]]></code>
            The <b>BatchRegistrationCallback</b> can be supplied to some overloads of the
            <see cref="T:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions">RegisterManyForOpenGeneric</see> extension methods.
            The default behavior of the <b>RegisterManyForOpenGeneric</b> methods is to register a closed generic
            type with the corresponding implementation (and will throw when multiple implementations are found for
            a single closed generic service type). The given example overrides this default registration by 
            registering the found list of implementations (one or more) as collection of singletons for the given 
            closed generic service type.
            </example>
        </member>
        <member name="F:SimpleInjector.Extensions.AccessibilityOption.AllTypes">
            <summary>Load both public as internal types from the given assemblies.</summary>
        </member>
        <member name="F:SimpleInjector.Extensions.AccessibilityOption.PublicTypesOnly">
            <summary>Only load publicly exposed types from the given assemblies.</summary>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for registration many concrete types at
            once that implement the same open generic service types in the <see cref="T:SimpleInjector.Container"/>.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given set of
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic, publicly exposed types that are located in the given 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Reflection.Assembly[])">
            <summary>
            Registers all concrete, non-generic, publicly exposed types in the given set of
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with the supplied <paramref name="lifestyle"/>. When a found type implements multiple 
            closed-generic versions of the given <paramref name="openGenericServiceType"/>, both closed-generic
            service types will point at the same registration and return the same instance based on the caching
            behavior of the supplied <paramref name="lifestyle"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="lifestyle">The lifestyle that will be used for the registration of the types.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="lifestyle"/> or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic, publicly exposed types that are located in the given 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with the supplied <paramref name="lifestyle"/>. When a found type implements multiple 
            closed-generic versions of the given <paramref name="openGenericServiceType"/>, both closed-generic
            service types will point at the same registration and return the same instance based on the caching
            behavior of the supplied <paramref name="lifestyle"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="lifestyle">The lifestyle that will be used for the registration of the types.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="lifestyle"/> or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Reflection.Assembly[])">
            <summary>
            Allows registration of all concrete, public, non-generic types that are located in the given set of 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/>, 
            by supplying a <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each 
            found closed generic implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Allows registration of all concrete, public, non-generic types that are located in the given set of 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/>, 
            by supplying a <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each 
            found closed generic implementation of the given <paramref name="openGenericServiceType"/>.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">
            <summary>
            Registers all concrete, non-generic, publicly exposed types that are located in the given 
            <paramref name="assemblies"/> that implement the given 
            <paramref name="openGenericServiceType"/> with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Registers all concrete, non-generic, publicly exposed types that are located in the given 
            <paramref name="assemblies"/> that implement the given <paramref name="openGenericServiceType"/> 
            with a singleton lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>,
            <paramref name="openGenericServiceType"/>, or <paramref name="assemblies"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="openGenericServiceType"/> is not
            an open generic type.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the given set of 
            <paramref name="assemblies"/> contain multiple publicly exposed types that implement the same 
            closed generic version of the given <paramref name="openGenericServiceType"/>.</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Type[])">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a transient lifetime.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Extensions.BatchRegistrationCallback,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Allows registration of all supplied <paramref name="typesToRegister"/> by a closed generic 
            definition of the given <paramref name="openGenericServiceType"/>, by supplying a 
            <see cref="T:SimpleInjector.Extensions.BatchRegistrationCallback"/> delegate, that will be called for each found closed generic 
            implementation.
            If the list contains open generic types, matching closed generic versions of each open generic
            type will be added to the list of implementations that is passed on to the 
            <paramref name="callback"/> delegate.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="callback">The delegate that will be called for each found closed generic version of
            the given open generic <paramref name="openGenericServiceType"/> to do the actual registration.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, <paramref name="callback"/>, or 
            <paramref name="typesToRegister"/> contain a null reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Type[])">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a singleton lifetime.
            When a found type implements multiple 
            closed-generic versions of the given <paramref name="openGenericServiceType"/>, both closed-generic
            service types will return the exact same instance.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManySinglesForOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers all supplied <paramref name="typesToRegister"/> by a closed generic definition of the
            given <paramref name="openGenericServiceType"/> with a singleton lifetime.
            When a found type implements multiple 
            closed-generic versions of the given <paramref name="openGenericServiceType"/>, both closed-generic
            service types will return the exact same instance.
            </summary>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="typesToRegister">The list of types that must be registered according to the given
            <paramref name="openGenericServiceType"/> definition.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/>, 
            <paramref name="openGenericServiceType"/>, or <paramref name="typesToRegister"/> contain a null
            reference (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="typesToRegister"/> contains a null
            (Nothing in VB) element, when the <paramref name="openGenericServiceType"/> is not an open generic
            type, or one of the types supplied in <paramref name="typesToRegister"/> does not implement a 
            closed version of <paramref name="openGenericServiceType"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown when there are multiple types in the given
            <paramref name="typesToRegister"/> collection that implement the same closed version of the
            supplied <paramref name="openGenericServiceType"/>.
            </exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,System.Reflection.Assembly[])">
            <summary>
            Returns all public types that are located in the supplied <paramref name="assemblies"/> 
            and implement or inherit from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the
            registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Returns all public types that are located in the supplied <paramref name="assemblies"/> 
            and implement or inherit from the supplied <paramref name="openGenericServiceType"/>.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the registration.
            </remarks>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">
            <summary>
            Returns all public types that are located in the supplied <paramref name="assemblies"/> 
            and implement or inherit from the supplied <paramref name="openGenericServiceType"/>.
            Types that are considered to be decorators are not returned.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the
            registration.
            </remarks>
            <param name="container">The container to use.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.GetTypesToRegister(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Returns all public types that are located in the supplied <paramref name="assemblies"/> 
            and implement or inherit from the supplied <paramref name="openGenericServiceType"/>.
            Types that are considered to be decorators are not returned.
            </summary>
            <remarks>
            Use this method when you need influence the types that are registered using 
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>. 
            The <b>RegisterManyForOpenGeneric</b> overloads that take a collection of <see cref="T:System.Reflection.Assembly"/> 
            objects use this method to get the list of types that need to be registered. Instead of calling 
            such overload, you can call an overload that takes a list of <see cref="T:System.Type"/> objects and pass 
            in a filtered result from this <b>GetTypesToRegister</b> method.
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            var types = OpenGenericBatchRegistrationExtensions
                .GetTypesToRegister(typeof(ICommandHandler<>), typeof(ICommandHandler<>).Assembly)
                .Where(type => !type.Name.EndsWith("Decorator"));
            
            container.RegisterManyForOpenGeneric(typeof(ICommandHandler<>), types);
            ]]></code>
            This example calls the <b>GetTypesToRegister</b> method to request a list of concrete implementations
            of the <b>ICommandHandler&lt;T&gt;</b> interface from the assembly of that interface. After that
            all types which name ends with 'Decorator' are filtered out. This list is supplied to an
            <see cref="M:SimpleInjector.Extensions.OpenGenericBatchRegistrationExtensions.RegisterManyForOpenGeneric(SimpleInjector.Container,System.Type,System.Reflection.Assembly[])">RegisterManyForOpenGeneric</see>
            overload that takes a list of types to finish the registration.
            </remarks>
            <param name="container">The container to use.</param>
            <param name="openGenericServiceType">The definition of the open generic type.</param>
            <param name="assemblies">A list of assemblies that will be searched.</param>
            <returns>A list of types.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="openGenericServiceType"/>, or 
            <paramref name="assemblies"/> contain a null reference (Nothing in VB).</exception>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for registration of open generic service
            types in the <see cref="T:SimpleInjector.Container"/>.
            </summary>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that a new instance of <paramref name="openGenericImplementation"/> will be returned 
            every time a <paramref name="openGenericServiceType"/> is requested.
            </summary>
            <example>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric(Container,Type,Type,Lifestyle)</see>
            overload for an example.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="openGenericImplementation">The definition of the open generic implementation type
            that will be returned when a <paramref name="openGenericServiceType"/> is requested.</param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterSingleOpenGeneric(SimpleInjector.Container,System.Type,System.Type)">
            <summary>
            Registers that the same instance of <paramref name="openGenericImplementation"/> will be returned 
            every time a <paramref name="openGenericServiceType"/> is requested.
            </summary>
            <example>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">RegisterOpenGeneric(Container,Type,Type,Lifestyle)</see>
            overload for an example.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances..</param>
            <param name="openGenericImplementation">The definition of the open generic implementation type
            that will be returned when a <paramref name="openGenericServiceType"/> is requested.</param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterOpenGeneric(SimpleInjector.Container,System.Type,System.Type,SimpleInjector.Lifestyle)">
            <summary>
            Registers that a closed generic instance of the supplied 
            <paramref name="openGenericImplementation"/> will be returned when a closed generic version of
            the <paramref name="openGenericServiceType"/> is requested. The instance will be cached 
            according to the specified <paramref name="lifestyle"/>.
            </summary>
            <remarks>
            Types registered using the <b>RegisterOpenGeneric</b> are resolved using unregistered type
            resolution. This means that an explicit registration made for a closed generic version of the
            <paramref name="openGenericServiceType"/> always gets resolved first and the given
            <paramref name="openGenericImplementation"/> only gets resolved when there is no such registration.
            </remarks>
            <example>
            The following example shows the definition of a generic <b>IValidator&lt;T&gt;</b> interface
            and, a <b>NullValidator&lt;T&gt;</b> implementation and a specific validator for Orders.
            The registration ensures a <b>OrderValidator</b> is returned when a 
            <b>IValidator&lt;Order&gt;</b> is requested. For all requests for a 
            <b>IValidator&lt;T&gt;</b> other than a <b>IValidator&lt;Order&gt;</b>, an 
            implementation of <b>NullValidator&lt;T&gt;</b> will be returned.
            <code lang="cs"><![CDATA[
            public interface IValidator<T>
            { 
                void Validate(T instance);
            }
            
            public class NullValidator<T> : IValidator<T>
            {
                public void Validate(T instance)
                {
                }
            }
            
            public class OrderValidator : IValidator<Order>
            {
                public void Validate(Order instance)
                {
                    if (instance.Total < 0)
                    {
                        throw new ValidationException("Total can not be negative.");
                    }
                }
            }
            
            [TestMethod]
            public static void TestRegisterOpenGeneric()
            {
                // Arrange
                var container = new Container();
                
                container.Register<IValidator<Order>, OrderValidator>(Lifestyle.Transient);
                container.RegisterOpenGeneric(typeof(IValidator<>), typeof(NullValidator<>), Lifestyle.Singleton);
                
                // Act
                var orderValidator = container.GetInstance<IValidator<Order>>();
                var customerValidator = container.GetInstance<IValidator<Customer>>();
                var productValidator = container.GetInstance<IValidator<Product>>();
            
                // Assert
                Assert.IsInstanceOfType(orderValidator, typeof(OrderValidator));
                Assert.IsInstanceOfType(customerValidator, typeof(NullValidator<Customer>));
                Assert.IsInstanceOfType(productValidator, typeof(NullValidator<Product>));
            }
            ]]></code>
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="openGenericImplementation">The definition of the open generic implementation type
            that will be returned when a <paramref name="openGenericServiceType"/> is requested.</param>
            <param name="lifestyle">The lifestyle that defines how returned instances are cached.</param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,System.Type[])">
            <summary>
            Registers that instances of <paramref name="openGenericImplementations"/> will be returned 
            when a collection of <paramref name="openGenericServiceType"/> is requested. New instances of 
            the registered <paramref name="openGenericImplementations"/> will be returned whenever the
            resolved collection is itereated.
            </summary>
            <example>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Collections.Generic.IEnumerable{System.Type})">RegisterAllOpenGeneric(Container,Type,Lifestyle,IEnumerable&lt;Type&gt;)</see>
            overload for an example.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="openGenericImplementations">The list of open generic implementation types
            that will be returned when a collection of <paramref name="openGenericServiceType"/> is requested.
            </param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers that instances of <paramref name="openGenericImplementations"/> will be returned 
            when a collection of <paramref name="openGenericServiceType"/> is requested. New instances of 
            the registered <paramref name="openGenericImplementations"/> will be returned whenever the
            resolved collection is itereated.
            </summary>
            <example>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Collections.Generic.IEnumerable{System.Type})">RegisterAllOpenGeneric(Container,Type,Lifestyle,IEnumerable&lt;Type&gt;)</see>
            overload for an example.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="openGenericImplementations">The list of open generic implementation types
            that will be returned when a collection of <paramref name="openGenericServiceType"/> is requested.
            </param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Type[])">
            <summary>
            Registers that instances of <paramref name="openGenericImplementations"/> will be returned 
            when a collection of <paramref name="openGenericServiceType"/> is requested. The instances will be 
            cached according to the specified <paramref name="lifestyle"/>.
            </summary>
            <example>
            Please see the 
            <see cref="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Collections.Generic.IEnumerable{System.Type})">RegisterAllOpenGeneric(Container,Type,Lifestyle,IEnumerable&lt;Type&gt;)</see>
            overload for an example.
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="lifestyle">The lifestyle that defines how returned instances are cached.</param>
            <param name="openGenericImplementations">The list of open generic implementation types
            that will be returned when a collection of <paramref name="openGenericServiceType"/> is requested.
            </param>
        </member>
        <member name="M:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.RegisterAllOpenGeneric(SimpleInjector.Container,System.Type,SimpleInjector.Lifestyle,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Registers that instances of <paramref name="openGenericImplementations"/> will be returned 
            when a collection of <paramref name="openGenericServiceType"/> is requested. The instances will be 
            cached according to the specified <paramref name="lifestyle"/>.
            </summary>
            <remarks>
            <para>
            Collections registered using the <b>RegisterAllOpenGeneric</b> are resolved using unregistered type
            resolution. This means that an explicit registration made for a collection of the closed generic 
            version of the <paramref name="openGenericServiceType"/> always gets resolved first and a 
            collection of <paramref name="openGenericImplementations"/> only gets resolved when there is no 
            such registration.
            </para>
            </remarks>
            <example>
            The following example shows the definition of a generic <b>IValidator&lt;T&gt;</b> interface
            and, a <b>NullValidator&lt;T&gt;</b> implementation and a specific validator for Orders.
            The registration ensures a <b>OrderValidator</b> is returned when a 
            <b>IValidator&lt;Order&gt;</b> is requested. For all requests for a 
            <b>IValidator&lt;T&gt;</b> other than a <b>IValidator&lt;Order&gt;</b>, an 
            implementation of <b>NullValidator&lt;T&gt;</b> will be returned.
            <code lang="cs"><![CDATA[
            public interface IValidator<T>
            { 
                void Validate(T instance);
            }
            
            public class DefaultValidator<T> : IValidator<T>
            {
                public void Validate(T instance)
                {
                    // some default validation
                }
            }
            
            [TestMethod]
            public static void TestRegisterAllOpenGeneric()
            {
                // Arrange
                var container = new Container();
                
                Type[] types = new[] { typeof(OrderValidator), typeof(DefaultValidator<>) };
                
                container.RegisterManyForOpenGeneric(typeof(IValidator<>),
                    (serviceType, implementationTypes) => container.RegisterAll(serviceType, implementationTypes), 
                    types);
                
                container.RegisterAllOpenGeneric(typeof(IValidator<>), typeof(DefaultValidator<>));
                
                // Act
                var orderValidators = container.GetAllInstances<IValidator<Order>>();
                var customerValidators = container.GetAllInstances<IValidator<Customer>>();
            
                // Assert
                Assert.IsTrue(orderValidators.SequenceEqual(
                    new[] { typeof(OrderValidator), typeof(DefaultValidator<Order>) }));
                
                // Without the call to RegisterAllOpenGeneric this customerValidators would be empty.
                Assert.IsTrue(customerValidators.SequenceEqual(new[] { typeof(DefaultValidator<Customer>) }));
            }
            ]]></code>
            </example>
            <param name="container">The container to make the registrations in.</param>
            <param name="openGenericServiceType">The definition of the open generic service type that can be 
            used to retrieve instances.</param>
            <param name="lifestyle">The lifestyle that defines how returned instances are cached.</param>
            <param name="openGenericImplementations">The list of open generic implementation types
            that will be returned when a collection of <paramref name="openGenericServiceType"/> is requested.
            </param>
        </member>
        <member name="T:SimpleInjector.Extensions.OpenGenericRegistrationExtensions.UnregisteredOpenGenericResolver">
            <summary>Resolves a given open generic type.</summary>
        </member>
        <member name="T:SimpleInjector.Helpers">
            <summary>
            Helper methods for the container.
            </summary>
        </member>
        <member name="T:SimpleInjector.InstanceProducer">
            <summary>
            Produces instances for a given registration. Instances of this type are generally created by the
            container when calling one of the <b>Register</b> overloads. Instances can be retrieved by calling
            <see cref="M:SimpleInjector.Container.GetCurrentRegistrations"/> or <see cref="M:SimpleInjector.Container.GetRegistration(System.Type,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:SimpleInjector.InstanceProducer.#ctor(System.Type,SimpleInjector.Registration)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.InstanceProducer"/> class.</summary>
            <param name="serviceType">The service type for which this instance is created.</param>
            <param name="registration">The <see cref="P:SimpleInjector.InstanceProducer.Registration"/>.</param>
        </member>
        <member name="M:SimpleInjector.InstanceProducer.GetInstance">
            <summary>Produces an instance.</summary>
            <returns>An instance. Will never return null.</returns>
            <exception cref="T:SimpleInjector.ActivationException">When the instance could not be retrieved or is null.</exception>
        </member>
        <member name="M:SimpleInjector.InstanceProducer.BuildExpression">
            <summary>
            Builds an expression that expresses the intent to get an instance by the current producer. A call 
            to this method locks the container. No new registrations can't be made after a call to this method.
            </summary>
            <returns>An Expression.</returns>
        </member>
        <member name="P:SimpleInjector.InstanceProducer.Lifestyle">
            <summary>
            Gets the <see cref="P:SimpleInjector.InstanceProducer.Lifestyle"/> for this registration. The returned lifestyle can differ from the
            lifestyle that is used during the registration. This can happen for instance when the registration
            is changed by an <see cref="E:SimpleInjector.Container.ExpressionBuilt">ExpressionBuilt</see> registration or
            gets <see cref="T:SimpleInjector.Extensions.DecoratorExtensions">decorated</see>.
            </summary>
            <value>The <see cref="P:SimpleInjector.InstanceProducer.Lifestyle"/> for this registration.</value>
        </member>
        <member name="P:SimpleInjector.InstanceProducer.ServiceType">
            <summary>Gets the service type for which this producer produces instances.</summary>
            <value>A <see cref="T:System.Type"/> instance.</value>
        </member>
        <member name="P:SimpleInjector.InstanceProducer.Registration">
            <summary>
            Gets the <see cref="P:SimpleInjector.InstanceProducer.Registration"/> instance for this instance.
            </summary>
            <value>The <see cref="P:SimpleInjector.InstanceProducer.Registration"/>.</value>
        </member>
        <member name="T:SimpleInjector.CreateLifestyleApplier">
            <summary>
            Factory for the creation of a delegate that applies caching to the supplied 
            <paramref name="transientInstanceCreator"/>.
            </summary>
            <param name="transientInstanceCreator">A factory for creating new instances.</param>
            <returns>A factory that returns cached instances.</returns>
        </member>
        <member name="T:SimpleInjector.Lifestyle">
            <summary>
            Instances returned from the container can be cached. The <see cref="T:SimpleInjector.Container"/> contains several
            overloads of the <b>Register</b> method that take a <b>Lifestyle</b> instance as argument to define 
            how returned instances should be cached. The core library contains two lifestyles out of the box. By
            supplying <see cref="F:SimpleInjector.Lifestyle.Transient">Lifestyle.Transient</see>, the registered instance is not
            cached; a new instance is returned every time it is requested or injected. By supplying
            <see cref="F:SimpleInjector.Lifestyle.Singleton">Lifestyle.Singleton</see> instances can be cached indefinately; only
            a single instance of the registered component will be returned by that container instance. Other
            lifestyles are defined in integration and extension packages. The 
            <see cref="M:SimpleInjector.Lifestyle.CreateCustom(System.String,SimpleInjector.CreateLifestyleApplier)">CreateCustom</see> method allows defining a custom lifestyle and 
            the <see cref="M:SimpleInjector.Lifestyle.CreateHybrid(System.Func{System.Boolean},SimpleInjector.Lifestyle,SimpleInjector.Lifestyle)">CreateHybrid</see> method allows creating a lifestle that mixes 
            multiple other lifestyles.
            </summary>
            <remarks>
            This type is abstract and can be overridden to implement a custom lifestyle.
            </remarks>
        </member>
        <member name="F:SimpleInjector.Lifestyle.Transient">
            <summary>
            The lifestyle instance that doesn't cache instances. A new instance of the specified
            component is created every time the registered service it is requested or injected.
            </summary>
            <example>
            The following example registers the <c>SomeServiceImpl</c> implementation for the
            <c>ISomeService</c> service type using the <b>Transient</b> lifestyle:
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            container.Register<ISomeService, SomeServiceImpl>(Lifestyle.Transient);
            ]]></code>
            Note that <b>Transient</b> is the default lifestyle, the previous registration can be reduced to
            the following:
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            // Transient registration.
            container.Register<ISomeService, SomeServiceImpl>();
            ]]></code>
            </example>
        </member>
        <member name="F:SimpleInjector.Lifestyle.Singleton">
            <summary>
            The lifestyle that caches components during the lifetime of the <see cref="T:SimpleInjector.Container"/> instance
            and guarantees that only a single instance of that component is created for that instance. Since
            general use is to create a single <b>Container</b> instance for the lifetime of the application /
            AppDomain, this would mean that only a single instance of that component would exist during the
            lifetime of the application. In a multi-threaded applications, implementations registered using 
            this lifestyle must be thread-safe.
            </summary>
            <example>
            The following example registers the <c>RealTimeProvider</c> implementation for the
            <c>ITimeProvider</c> service type using the <b>Singleton</b> lifestyle:
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            container.Register<ITimeProvider, RealTimeProvider>(Lifestyle.Singleton);
            ]]></code>
            Note that using the 
            <see cref="M:SimpleInjector.Container.RegisterSingle``2">RegisterSingle</see> method has 
            the same effect:
            <code lang="cs"><![CDATA[
            var container = new Container();
            
            // Singleton registration.
            container.RegisterSingle<ITimeProvider, RealTimeProvider>();
            ]]></code>
            </example>
        </member>
        <member name="M:SimpleInjector.Lifestyle.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:SimpleInjector.Lifestyle"/> class.</summary>
            <param name="name">The user friendly name of this lifestyle.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="name"/> is null (Nothing in VB) 
            or an empty string.</exception>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateHybrid(System.Func{System.Boolean},SimpleInjector.Lifestyle,SimpleInjector.Lifestyle)">
            <summary>
            The hybrid lifestyle allows mixing two lifestyles in a single registration. Based on the supplied
            <paramref name="lifestyleSelector"/> delegate the hybrid lifestyle will redirect the creation of 
            the instance to the correct lifestyle. The result of the <paramref name="lifestyleSelector"/> 
            delegate will not be cached; it is invoked each time an instance is requested or injected. By 
            nesting hybrid lifestyles, any number of lifestyles can be mixed.
            </summary>
            <param name="lifestyleSelector">The <see cref="T:System.Func`1"/> delegate that determines which 
            lifestyle should be used. The <paramref name="trueLifestyle"/> will be used if <b>true</b> is 
            returned; the <paramref name="falseLifestyle"/> otherwise. This delegate will be called every
            time an instance needs to be resolved or injected.</param>
            <param name="trueLifestyle">The lifestyle to use when <paramref name="lifestyleSelector"/> 
            returns <b>true</b>.</param>
            <param name="falseLifestyle">The lifestyle to use when <paramref name="lifestyleSelector"/> 
            returns <b>false</b>.</param>
            <returns>A new hybrid lifestyle that wraps the supplied lifestyles.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the supplied arguments is a null
            reference (Nothing in VB).</exception>
            <example>
            <para>
            The following example shows the creation of a <b>HybridLifestyle</b> that mixes an 
            <b>WebRequestLifestyle</b> and <b>LifetimeScopeLifestyle</b>:
            </para>
            <code lang="cs"><![CDATA[
            // NOTE: WebRequestLifestyle is located in SimpleInjector.Integration.Web.dll.
            // NOTE: LifetimeScopeLifestyle is located in SimpleInjector.Extensions.LifetimeScoping.dll.
            var mixedScopeLifestyle = Lifestyle.CreateHybrid(
                () => HttpContext.Current != null,
                new WebRequestLifestyle(),
                new LifetimeScopeLifestyle());
            
            // The created lifestyle can be reused for many registrations.
            container.Register<IUserRepository, SqlUserRepository>(mixedScopeLifestyle);
            container.Register<ICustomerRepository, SqlCustomerRepository>(mixedScopeLifestyle);
            ]]></code>
            <para>
            Hybrid lifestyles can be nested:
            </para>
            <code lang="cs"><![CDATA[
            var mixedLifetimeTransientLifestyle = Lifestyle.CreateHybrid(
                () => container.GetCurrentLifetimeScope() != null,
                new LifetimeScopeLifestyle(),
                Lifestyle.Transient);
            
            var mixedScopeLifestyle = Lifestyle.CreateHybrid(
                () => HttpContext.Current != null,
                new WebRequestLifestyle(),
                mixedLifetimeTransientLifestyle);
            ]]></code>
            <para>
            The <b>mixedScopeLifestyle</b> now mixed three lifestyles: Web Request, Lifetime Scope and 
            Transient.
            </para>
            </example>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateCustom(System.String,SimpleInjector.CreateLifestyleApplier)">
            <summary>
            Creates a custom lifestyle using the supplied <paramref name="lifestyleApplierFactory"/> delegate.
            </summary>
            <remarks>
            The supplied <paramref name="lifestyleApplierFactory"/> will be called just once per registered 
            service. The supplied <paramref name="lifestyleApplierFactory"/> will be called by the framework
            when the type is resolved for the first time, and the framework will supply the factory with a
            <b>Func&lt;object&gt;</b> for creating new (transient) instances of that type (that might
            have been <see cref="E:SimpleInjector.Container.ExpressionBuilding">intercepted</see> and
            <see cref="M:SimpleInjector.Container.RegisterInitializer``1(System.Action{``0})">initializers</see> might have been applied). It is the
            job of the <paramref name="lifestyleApplierFactory"/> to return a <b>Func&lt;object&gt;</b> that
            applies the proper caching. The <b>Func&lt;object&gt;</b> that is returned by the 
            <paramref name="lifestyleApplierFactory"/> will be stored for that registration (every 
            registration will store its own <b>Func&lt;object&gt;</b> delegate) and this delegate will be
            called everytime the service is resolved (by calling 
            <code>container.GetInstance&lt;TService&gt;</code> or when that service is injected into another
            type). 
            </remarks>
            <param name="name">The name of the lifestyle to create. The name is used to display the lifestyle
            in the debugger.</param>
            <param name="lifestyleApplierFactory">A factory delegate that takes a <b>Func&lt;object&gt;</b> delegate
            that will produce a transient instance and returns a delegate that returns cached instances.</param>
            <returns>A new <see cref="T:SimpleInjector.Lifestyle"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the arguments is a null reference
            (Nothing in VB).</exception>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="name"/> is an empty string.</exception>
            <example>
            The following example shows the creation of a lifestyle that caches registered instances for 10
            minutes:
            <code lang="cs"><![CDATA[
            var customLifestyle = Lifestyle.CreateCustom("Absolute 10 Minute Expiration", instanceCreator =>
            {
                TimeSpan timeout = TimeSpan.FromMinutes(10);
                var syncRoot = new object();
                var expirationTime = DateTime.MinValue;
                object instance = null;
            
                // If the application has multiple registrations using this lifestyle, each registration
                // will get its own Func<object> delegate (created here) and therefore get its own set
                // of variables as defined above.
                return () =>
                {
                    lock (syncRoot)
                    {
                        if (expirationTime < DateTime.UtcNow)
                        {
                            instance = instanceCreator();
                            expirationTime = DateTime.UtcNow.Add(timeout);
                        }
            
                        return instance;
                    }
                };
            });
            
            var container = new Container();
            
            // We can reuse the created lifestyle for multiple registrations.
            container.Register<IService, MyService>(customLifestyle);
            container.Register<AnotherService, MeTwoService>(customLifestyle);
            ]]></code>
            </example>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistration``2(SimpleInjector.Container)">
            <summary>
            Creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <typeparamref name="TImplementation"/> with the caching as specified by this lifestyle.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="container"/> is a null
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistration``1(System.Func{``0},SimpleInjector.Container)">
            <summary>
            Creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <typeparamref name="TService"/> using the supplied <paramref name="instanceCreator"/> 
            with the caching as specified by this lifestyle.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <param name="instanceCreator">A delegate that will create a new instance of 
            <typeparamref name="TService"/> every time it is called.</param>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when either <paramref name="instanceCreator"/> or
            <paramref name="container"/> are null references (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistration(System.Type,System.Type,SimpleInjector.Container)">
            <summary>
            Creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <paramref name="implementationType"/> with the caching as specified by this lifestyle.
            This method might fail when run in a partial trust sandbox when <paramref name="implementationType"/>
            is an internal type.
            </summary>
            <param name="serviceType">The interface or base type that can be used to retrieve the instances.</param>
            <param name="implementationType">The concrete type that will be registered.</param>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when on of the supplied arguments is a null 
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistration(System.Type,System.Func{System.Object},SimpleInjector.Container)">
            <summary>
            Creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <paramref name="serviceType"/>  using the supplied <paramref name="instanceCreator"/> 
            with the caching as specified by this lifestyle.
            </summary>
            <param name="serviceType">The interface or base type that can be used to retrieve the instances.</param>
            <param name="instanceCreator">The delegate that will be responsible for creating new instances.</param>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when on of the supplied arguments is a null 
            reference (Nothing in VB).</exception>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistrationCore``2(SimpleInjector.Container)">
            <summary>
            When overridden in a derived class, 
            creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <typeparamref name="TImplementation"/> with the caching as specified by this lifestyle.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <typeparam name="TImplementation">The concrete type that will be registered.</typeparam>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <remarks>
            If you are implementing your own lifestyle, override this method to implement the code necessary 
            to create and return a new <see cref="T:SimpleInjector.Registration"/>. Note that you should <b>always</b> create
            a new <see cref="T:SimpleInjector.Registration"/> instance. They should never be cached.
            </remarks>
        </member>
        <member name="M:SimpleInjector.Lifestyle.CreateRegistrationCore``1(System.Func{``0},SimpleInjector.Container)">
            <summary>
            When overridden in a derived class, 
            creates a new <see cref="T:SimpleInjector.Registration"/> instance defining the creation of the
            specified <typeparamref name="TService"/> using the supplied <paramref name="instanceCreator"/> 
            with the caching as specified by this lifestyle.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve the instances.</typeparam>
            <param name="instanceCreator">A delegate that will create a new instance of 
            <typeparamref name="TService"/> every time it is called.</param>
            <param name="container">The <see cref="T:SimpleInjector.Container"/> instance for which a 
            <see cref="T:SimpleInjector.Registration"/> must be created.</param>
            <returns>A new <see cref="T:SimpleInjector.Registration"/> instance.</returns>
            <remarks>
            If you are implementing your own lifestyle, override this method to implement the code necessary 
            to create and return a new <see cref="T:SimpleInjector.Registration"/>. Note that you should <b>always</b> create
            a new <see cref="T:SimpleInjector.Registration"/> instance. They should never be cached.
            </remarks>
        </member>
        <member name="P:SimpleInjector.Lifestyle.Name">
            <summary>Gets the user friendly name of this lifestyle.</summary>
            <value>The user friendly name of this lifestyle.</value>
        </member>
        <member name="P:SimpleInjector.Lifestyle.Length">
            <summary>
            Gets the length of the lifestyle. Implementers must implement this property. The diagnostic
            services use this value to compare lifestyles with each other to determine lifestyle 
            misconfigurations.
            </summary>
            <value>The <see cref="T:System.Int32"/> representing the length of this lifestyle.</value>
        </member>
        <member name="T:SimpleInjector.StringResources">
            <summary>Internal helper for string resources.</summary>
        </member>
        <member name="T:SimpleInjector.UnregisteredTypeEventArgs">
            <summary>
            Provides data for and interaction with the 
            <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event of 
            the <see cref="T:SimpleInjector.Container"/>. An observer can check the 
            <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> to see whether the unregistered type can be handled. The
            <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})"/> method can be called to register a <see cref="T:System.Func`1"/> delegate 
            that allows creation of instances of the unregistered for this and future requests.
            </summary>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.#ctor(System.Type)">
            <summary>Initializes a new instance of the UnregisteredTypeEventArgs class.</summary>
            <param name="unregisteredServiceType">The unregistered service type.</param>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})">
            <summary>
            Registers a <see cref="T:System.Func`1"/> delegate that allows creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> for this and future requests. The delegate
            will be caches and future requests will directly call that delegate.
            </summary>
            <param name="instanceCreator">The delegate that allows creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="instanceCreator"/> is a
            null reference.</exception>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when multiple observers that have registered to
            the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event
            called this method for the same type.</exception>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Linq.Expressions.Expression)">
            <summary>
            Registers an <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.Expression"/> that describes the creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> for this and future requests. The delegate
            will be cached and future requests will directly use that expression or the compiled delegate.
            </summary>
            <remarks>
            NOTE: If possible, use the <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(SimpleInjector.Registration)">Register(Registration)</see> overload,
            since this allows the analysis services to determine any configuration errors on the lifestyle of
            the registration.
            </remarks>
            <param name="expression">The expression that describes the creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="expression"/> is a
            null reference.</exception>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when multiple observers that have registered to
            the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event
            called this method for the same type.</exception>
        </member>
        <member name="M:SimpleInjector.UnregisteredTypeEventArgs.Register(SimpleInjector.Registration)">
            <summary>
            Registers a <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.Registration"/> that describes the creation of instances of the type
            expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/> for this and future requests. The 
            registration will be cached and future requests will directly call unon that registration, the
            expression that it generates or the delegate that gets compiled from that expression.
            </summary>
            <param name="registration">The registration that describes the creation of instances according to
            the registration's lifestyle of the type expressed by the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the <paramref name="registration"/> is a
            null reference.</exception>
            <exception cref="T:System.ArgumentException">Thrown when the <paramref name="registration"/> is a
            not exactly of type <see cref="T:System.Func`1"/> where T equals the <see cref="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType"/>.
            </exception>
            <exception cref="T:SimpleInjector.ActivationException">Thrown when multiple observers that have registered to
            the <see cref="E:SimpleInjector.Container.ResolveUnregisteredType">ResolveUnregisteredType</see> event
            called this method for the same type.</exception>
        </member>
        <member name="P:SimpleInjector.UnregisteredTypeEventArgs.UnregisteredServiceType">
            <summary>Gets the unregistered service type that is currently requested.</summary>
            <value>The unregistered service type that is currently requested.</value>
        </member>
        <member name="P:SimpleInjector.UnregisteredTypeEventArgs.Handled">
            <summary>
            Gets a value indicating whether the event represented by this instance has been handled. 
            This property will return <b>true</b> when <see cref="M:SimpleInjector.UnregisteredTypeEventArgs.Register(System.Func{System.Object})"/> has been called on
            this instance.
            </summary>
            <value>The indication whether the event has been handled.</value>
        </member>
        <member name="T:SimpleInjector.Advanced.ThreadLocalValue">
            <summary>
            This class is for internal use only.
            </summary>
        </member>
        <member name="P:SimpleInjector.Advanced.ThreadLocalValue.Value">
            <summary>Gets or sets the value.</summary>
            <value>The value.</value>
        </member>
    </members>
</doc>
